\section{Stereo\+Camera Class Reference}
\label{classStereoCamera}\index{Stereo\+Camera@{Stereo\+Camera}}


The base class defining stereo camera.  




{\ttfamily \#include $<$stereo\+Camera.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classStereoCamera_a11256fe5a509436abc714a594b6cc801}{Stereo\+Camera} (bool rectify=true)
\begin{DoxyCompactList}\small\item\em Default Constructor. \end{DoxyCompactList}\item 
\hyperlink{classStereoCamera_a0c2cd4c7b5a0cdb96370c29a42601f40}{Stereo\+Camera} (yarp\+::os\+::\+Resource\+Finder \&rf, bool rectify=true)
\begin{DoxyCompactList}\small\item\em Costructor for initialization from file. \end{DoxyCompactList}\item 
\hyperlink{classStereoCamera_a5bfcf3ef7c9d45802bacbf040e7ca112}{Stereo\+Camera} (\hyperlink{classCamera}{Camera} First, \hyperlink{classCamera}{Camera} Second, bool rectify=true)
\begin{DoxyCompactList}\small\item\em Constructor for initialization using two calibrated cameras. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a398f45eeefe7979a834659cfbb7a6961}{stereo\+Calibration} (vector$<$ string $>$ image\+List, int board\+Width, int board\+Height, float sqsize=1.\+0)
\begin{DoxyCompactList}\small\item\em It performs the stereo camera calibration. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a9f06cd4b170ad0ba45b681ee93d64851}{save\+Calibration} (string extrinsic\+File\+Path, string intrinsic\+File\+Path)
\begin{DoxyCompactList}\small\item\em It saves the calibration. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a5e24f7d17a11adb4a6310df7f7e2de5b}{set\+Images} (Ipl\+Image $\ast$first\+Img, Ipl\+Image $\ast$second\+Img)
\begin{DoxyCompactList}\small\item\em It stores in memory a couple of images. \end{DoxyCompactList}\item 
cv\+::\+Mat \hyperlink{classStereoCamera_aeb1cf4e41058cd70c7df6b8c2511548d}{find\+Match} (bool visualize=false, double displacement=20.\+0, double radius=200.\+0)
\begin{DoxyCompactList}\small\item\em It finds matches between two images. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a79e986f2970bb2c5b5acd1ede65984aa}{compute\+Disparity} (bool best=true, int uniqueness\+Ratio=15, int speckle\+Window\+Size=50, int speckle\+Range=16, int number\+Of\+Disparities=64, int S\+A\+D\+Window\+Size=7, int min\+Disparity=0, int pre\+Filter\+Cap=63, int disp12\+Max\+Diff=0)
\begin{DoxyCompactList}\small\item\em It computes the Disparity Map using H. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a2751f357e5fabc7099303d45425208d7}{undistort\+Images} ()
\begin{DoxyCompactList}\small\item\em It undistorts the images. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_adf155975709fdbf09d3133899d074a02}{horn} (Mat \&K1, Mat \&K2, vector$<$ Point2f $>$ \&Points1, vector$<$ Point2f $>$ \&Points2, Mat \&Rot, Mat \&Tras)
\begin{DoxyCompactList}\small\item\em It performs the horn relative orientations algorithm i.\+e. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a36dae897d07544e8faca8c90216173a6}{horn\+Relative\+Orientations} ()
\begin{DoxyCompactList}\small\item\em It performs the horn relative orientations, all the parameters are assumed initialized in the \hyperlink{classStereoCamera}{Stereo\+Camera} object. \end{DoxyCompactList}\item 
Point3f \hyperlink{classStereoCamera_a3c8ef84424fa111c63437a3db8f04333}{triangulation} (Point2f \&point1, Point2f \&point2)
\begin{DoxyCompactList}\small\item\em It performs the triangulation using the stored in the internal P1 and P2 3x4 \hyperlink{classCamera}{Camera} Matrices. \end{DoxyCompactList}\item 
Point3f \hyperlink{classStereoCamera_ab68c8d3bd07f542243d681fbe8c8c6b7}{triangulation} (Point2f \&point1, Point2f \&point2, Mat Camera1, Mat Camera2)
\begin{DoxyCompactList}\small\item\em It performs the triangulation (H\+Z Chap 12.\+2 homogenous solution). \end{DoxyCompactList}\item 
Point3f \hyperlink{classStereoCamera_aaef25d8723eefdbab6e27c348492126b}{triangulation\+L\+S} (Point2f \&point1, Point2f \&point2, Mat Camera1, Mat Camera2)
\begin{DoxyCompactList}\small\item\em It performs the least square triangulation (H\+Z Chap 12.\+2 Inhomogenous solution). \end{DoxyCompactList}\item 
Point3f \hyperlink{classStereoCamera_a2fcd3e1767bcf04716b0e2ac76098430}{metric\+Triangulation} (Point2f \&point1, double th\+Meters=10)
\begin{DoxyCompactList}\small\item\em It performs the metric triangulation given the pixel coordinates on the first image. \end{DoxyCompactList}\item 
Point3f \hyperlink{classStereoCamera_a3cf53fac6336eea107a26bd5cdbbdd03}{metric\+Triangulation} (Point2f \&point1, Mat \&H, double th\+Meters=10)
\begin{DoxyCompactList}\small\item\em It performs the metric triangulation given the pixel coordinates on the first image. \end{DoxyCompactList}\item 
Point3f \hyperlink{classStereoCamera_a761ea623c4cde38b4fa1d798ef09b7ae}{triangulate\+Known\+Disparity} (float u, float v, float d, Mat \&H)
\begin{DoxyCompactList}\small\item\em It performs the metric triangulation given the pixel coordinates on the first image and the disparity between the two R\+E\+C\+T\+I\+F\+I\+E\+D images. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_ab2eded08bca185ac22cd6343cb4c85c8}{estimate\+Essential} ()
\begin{DoxyCompactList}\small\item\em It estimates the essential matrix (3x3) E between two views. \end{DoxyCompactList}\item 
bool \hyperlink{classStereoCamera_a180388e93b654802c7c56c18d206214b}{essential\+Decomposition} ()
\begin{DoxyCompactList}\small\item\em It decomposes the essential matrix in Rotation and Translation between the two views. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a245346dbef63e13807c5cd9160803d25}{chierality} (Mat \&R1, Mat \&R2, Mat \&t1, Mat \&t2, Mat \&R, Mat \&t, Vector$<$ Point2f $>$ points1, Vector$<$ Point2f $>$ points2)
\begin{DoxyCompactList}\small\item\em It performs the chierality test\+: given a couple of rotation matrices, translation vectors and matches it finds the correct rotation and translation s.\+t. \end{DoxyCompactList}\item 
const Mat \hyperlink{classStereoCamera_a57d155d519c621a7a580f41ec114df01}{get\+Im\+Left} ()
\begin{DoxyCompactList}\small\item\em It returns the left (first) image. \end{DoxyCompactList}\item 
const Mat \hyperlink{classStereoCamera_a09e72c3430250883aac6ab5a4d98961f}{get\+Im\+Right} ()
\begin{DoxyCompactList}\small\item\em It returns the right (second) image. \end{DoxyCompactList}\item 
const Mat \hyperlink{classStereoCamera_a48ff47fc8326d511677bef8bcf3a65bc}{get\+Im\+Left\+Und} ()
\begin{DoxyCompactList}\small\item\em It returns the left undistorted image. \end{DoxyCompactList}\item 
const Mat \hyperlink{classStereoCamera_a0485caf9bd52a7317776e5db495446a5}{get\+Im\+Right\+Und} ()
\begin{DoxyCompactList}\small\item\em It returns the right undistorted image. \end{DoxyCompactList}\item 
const Mat \hyperlink{classStereoCamera_a97607922d84e1a1a006cd7a5aec93a24}{get\+Disparity} ()
\begin{DoxyCompactList}\small\item\em It returns the disparity image. \end{DoxyCompactList}\item 
const Mat \hyperlink{classStereoCamera_a89f9890f50d85be9ebda7a0769279348}{get\+Disparity16} ()
\begin{DoxyCompactList}\small\item\em It returns the disparity image. \end{DoxyCompactList}\item 
const Mat \hyperlink{classStereoCamera_a43bd5710058d9ee0ed94dc8b74e5656c}{get\+Q} ()
\begin{DoxyCompactList}\small\item\em It returns the 4x4 disparity-\/to-\/depth mapping matrix. \end{DoxyCompactList}\item 
const Mat \hyperlink{classStereoCamera_a8533ec543166868e3db471bad0cb61a3}{get\+Kleft} ()
\begin{DoxyCompactList}\small\item\em It returns the 3x3 left camera matrix. \end{DoxyCompactList}\item 
const Mat \hyperlink{classStereoCamera_a62ea986b40a785e589704bb58750e15b}{get\+Kright} ()
\begin{DoxyCompactList}\small\item\em It returns the 3x3 right camera matrix. \end{DoxyCompactList}\item 
const Mat \hyperlink{classStereoCamera_a257d9f531c444b685a0b96ae3908c2d0}{get\+Fundamental} ()
\begin{DoxyCompactList}\small\item\em It returns the 3x3 fundamental matrix. \end{DoxyCompactList}\item 
const vector$<$ Point2f $>$ \hyperlink{classStereoCamera_ac42cf4193f379a3c0ecf5e40c61358f2}{get\+Match\+Left} ()
\begin{DoxyCompactList}\small\item\em It returns the pixel coordinates of the matches in the left image. \end{DoxyCompactList}\item 
const vector$<$ Point2f $>$ \hyperlink{classStereoCamera_ab35a9b702cd5213bd8d4de8491399201}{get\+Match\+Right} ()
\begin{DoxyCompactList}\small\item\em It returns the pixel coordinates of the matches in the right image. \end{DoxyCompactList}\item 
const Mat \hyperlink{classStereoCamera_a7c7df54191a3c73486c0136de18dd52e}{get\+Translation} ()
\begin{DoxyCompactList}\small\item\em It returns the translation vector between the two cameras. \end{DoxyCompactList}\item 
const Mat \hyperlink{classStereoCamera_a13fc8d5d205e09ab3d1bb8010829b0c1}{get\+Rotation} ()
\begin{DoxyCompactList}\small\item\em It returns the rotation matrix between the two cameras. \end{DoxyCompactList}\item 
const Mat \hyperlink{classStereoCamera_a6d7a3361adfda3a05eea2d5116ed2515}{get\+Mapper\+L} ()
\begin{DoxyCompactList}\small\item\em It returns the mapping between the original left camera and the rectified left camera. \end{DoxyCompactList}\item 
const Mat \hyperlink{classStereoCamera_a8cbd829aba62360200035bb452edc42b}{get\+Mapper\+R} ()
\begin{DoxyCompactList}\small\item\em It returns the mapping between the original right camera and the rectified right camera. \end{DoxyCompactList}\item 
const Mat \hyperlink{classStereoCamera_a986686c56d4bf5381ea57b3f49338af1}{get\+R\+Lrect} ()
\begin{DoxyCompactList}\small\item\em It returns the rotation matrix between the original left camera and the rectified left camera. \end{DoxyCompactList}\item 
const Mat \hyperlink{classStereoCamera_a08979926b86d513f1b373109f5a4733d}{get\+R\+Rrect} ()
\begin{DoxyCompactList}\small\item\em It returns the rotation matrix between the original right camera and the rectified right camera. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a1329b3894d527e1505618f57a1304624}{set\+Rotation} (Mat \&Rot, int mode=0)
\begin{DoxyCompactList}\small\item\em It sets the rotation matrix (if known) between the first and the second camera. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a7b10f1218e8e70f47b22080ba1820d39}{set\+Translation} (Mat \&Tras, int mul=0)
\begin{DoxyCompactList}\small\item\em It sets the translation vector (if known) between the first and the second camera. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a54754623497c8dddb61f520e17f465f8}{set\+Intrinsics} (Mat \&K1, Mat \&K2, Mat \&Dist1, Mat \&Dist2)
\begin{DoxyCompactList}\small\item\em It sets the intrinsic parameters. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_ae5ac866c6d4b6c4819b01a918e7b61e0}{rectify\+Images} ()
\begin{DoxyCompactList}\small\item\em The method rectifies the two images\+: it transform each image plane such that pairs conjugate epipolar lines become collinear and parallel to one of the image axes (i.\+e. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a0bd4492f7f87862955da0bc5d0042cc8}{get\+L\+Rectified} ()
\begin{DoxyCompactList}\small\item\em The method returns the first rectified image. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_aaf4ba8eaa338ff24db1196849a96e5e9}{get\+R\+Rectified} ()
\begin{DoxyCompactList}\small\item\em The method returns the second rectified image. \end{DoxyCompactList}\item 
vector$<$ Point2f $>$ \hyperlink{classStereoCamera_a03406c9d31c1b765a8d6ef9641222309}{project\+Points3\+D} (string camera, vector$<$ Point3f $>$ \&points3\+D, Mat \&H)
\begin{DoxyCompactList}\small\item\em The method returns the 2\+D projection of a set of 3\+D points in the cartesian space to the specified camera. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a52ef2f3401488e5c4fa6badd1336f96d}{compute\+World\+Image} (Mat \&H)
\begin{DoxyCompactList}\small\item\em The method returns a 3-\/\+Channels float image with the world coordinates w.\+r.\+t H reference system. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a3edeb24b68ee4266f89982533ad1e9bf}{get\+Dist\+Coeff\+Right} ()
\begin{DoxyCompactList}\small\item\em It returns the 5x1 right distortion coefficients. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a4830201154ab288bd93f6cceb2c2daf5}{get\+Dist\+Coeff\+Left} ()
\begin{DoxyCompactList}\small\item\em It returns the 5x1 left distortion coefficients. \end{DoxyCompactList}\item 
Point2f \hyperlink{classStereoCamera_af64550bb8a7a665930dee5eea87b7e47}{get\+Distorted\+Pixel} (int u, int v, int cam=1)
\begin{DoxyCompactList}\small\item\em Given the u,v pixel coordinates in the undistorted image the method returns the original position of the pixel in the distorted frame. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a6580ff03c7cec5c385ec717f9c018e21}{draw\+Matches} ()
\begin{DoxyCompactList}\small\item\em The method returns a 3-\/\+Channels 8bit image with the image matches. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_ae683fafa11ea73e4b4c278402be259b6}{set\+Matches} (std\+::vector$<$ cv\+::\+Point2f $>$ \&points\+L, std\+::vector$<$ cv\+::\+Point2f $>$ \&points\+R)
\begin{DoxyCompactList}\small\item\em The function initialize the matches of the current image pair. \end{DoxyCompactList}\item 
void \hyperlink{classStereoCamera_a9ecb303d7b36eaf5f086d8ddebd29b95}{set\+Expected\+Position} (Mat \&Rot, Mat \&Tran)
\begin{DoxyCompactList}\small\item\em The function set the expected Rotation and Translation parameters for the current image pair. \end{DoxyCompactList}\item 
Mat \hyperlink{classStereoCamera_a3fe4e87322f8644cd21ce06e8522c815}{Ffrom\+P} (Mat \&P1, Mat \&P2)
\begin{DoxyCompactList}\small\item\em The function computes the fundamental matrix starting from known camera matrices. \end{DoxyCompactList}\item 
Point2f \hyperlink{classStereoCamera_a3d8fde0cbd4604085b883f22cc606c01}{from\+Rectified\+To\+Original} (int u, int v, int camera)
\begin{DoxyCompactList}\small\item\em Given the u,v pixel coordinates in the rectified image the method returns the position of the pixel in the non-\/rectified frame. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
The base class defining stereo camera. 

It allows to calibrate the cameras, to undistort a pair of images, to find matches between two images, to triangulate points and to estimate motion between two images. The basic assumption is that the two images come from a stereo camera, however this class works also with two arbitrary images. 

Definition at line 83 of file stereo\+Camera.\+h.



\subsection{Constructor \& Destructor Documentation}
\index{Stereo\+Camera@{Stereo\+Camera}!Stereo\+Camera@{Stereo\+Camera}}
\index{Stereo\+Camera@{Stereo\+Camera}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{Stereo\+Camera}]{\setlength{\rightskip}{0pt plus 5cm}Stereo\+Camera\+::\+Stereo\+Camera (
\begin{DoxyParamCaption}
\item[{bool}]{rectify = {\ttfamily true}}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a11256fe5a509436abc714a594b6cc801}


Default Constructor. 

You should initialize all the intrinsic and extrinsic parameters using the provided methods. 

Definition at line 57 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
57                                        \{
58     this->mutex=\textcolor{keyword}{new} Semaphore(1);
59     this->rectify=rectify;
60     this->epipolarTh=0.01;
61 
62 \textcolor{preprocessor}{#ifndef USING\_GPU}
63     cv::initModule\_nonfree();
64 \textcolor{preprocessor}{#endif }
65 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!Stereo\+Camera@{Stereo\+Camera}}
\index{Stereo\+Camera@{Stereo\+Camera}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{Stereo\+Camera}]{\setlength{\rightskip}{0pt plus 5cm}Stereo\+Camera\+::\+Stereo\+Camera (
\begin{DoxyParamCaption}
\item[{yarp\+::os\+::\+Resource\+Finder \&}]{rf, }
\item[{bool}]{rectify = {\ttfamily true}}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a0c2cd4c7b5a0cdb96370c29a42601f40}


Costructor for initialization from file. 


\begin{DoxyParams}{Parameters}
{\em rf} & is the config file generated by the stereo\+Calib module. \\
\hline
\end{DoxyParams}


Definition at line 67 of file stereo\+Camera.\+cpp.



References set\+Intrinsics(), set\+Rotation(), and set\+Translation().


\begin{DoxyCode}
67                                                                  \{
68         Mat KL, KR, DistL, DistR, R, T;
69         loadStereoParameters(rf,KL,KR,DistL,DistR,R,T);
70         this->mutex= \textcolor{keyword}{new} Semaphore(1);
71         this->setIntrinsics(KL,KR,DistL,DistR);
72         this->setRotation(R,0);
73         this->setTranslation(T,0);
74 
75         this->cameraChanged=\textcolor{keyword}{true};
76         this->epipolarTh=0.01;
77         this->rectify=rectify;
78         buildUndistortRemap();
79 
80 \textcolor{preprocessor}{    #ifndef USING\_GPU}
81         cv::initModule\_nonfree();
82 \textcolor{preprocessor}{    #endif }
83 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!Stereo\+Camera@{Stereo\+Camera}}
\index{Stereo\+Camera@{Stereo\+Camera}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{Stereo\+Camera}]{\setlength{\rightskip}{0pt plus 5cm}Stereo\+Camera\+::\+Stereo\+Camera (
\begin{DoxyParamCaption}
\item[{{\bf Camera}}]{First, }
\item[{{\bf Camera}}]{Second, }
\item[{bool}]{rectify = {\ttfamily true}}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a5bfcf3ef7c9d45802bacbf040e7ca112}


Constructor for initialization using two calibrated cameras. 

\begin{DoxyNote}{Note}
Only intrinsic parameters are initialized. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em First} & the first camera (Left eye is assumed but you can use any arbitrary camera). The 3\+D point coordinates have this reference system. \\
\hline
{\em Second} & the second camera (Right eye is assumed). \\
\hline
\end{DoxyParams}


Definition at line 85 of file stereo\+Camera.\+cpp.



References Camera\+::get\+Camera\+Matrix(), and Camera\+::get\+Dist\+Vector().


\begin{DoxyCode}
85                                                                  \{
86     this->Kleft=Left.getCameraMatrix();
87     this->DistL=Left.getDistVector();
88 
89     this->Kright=Right.getCameraMatrix();
90     this->DistR=Right.getDistVector();
91     this->mutex=\textcolor{keyword}{new} Semaphore(1);
92     this->cameraChanged=\textcolor{keyword}{true};
93     this->rectify=rectify;
94     this->epipolarTh=0.01;
95     buildUndistortRemap();
96 
97 \textcolor{preprocessor}{#ifndef USING\_GPU}
98     cv::initModule\_nonfree();
99 \textcolor{preprocessor}{#endif }
100 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{Stereo\+Camera@{Stereo\+Camera}!chierality@{chierality}}
\index{chierality@{chierality}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{chierality}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::chierality (
\begin{DoxyParamCaption}
\item[{Mat \&}]{R1, }
\item[{Mat \&}]{R2, }
\item[{Mat \&}]{t1, }
\item[{Mat \&}]{t2, }
\item[{Mat \&}]{R, }
\item[{Mat \&}]{t, }
\item[{Vector$<$ Point2f $>$}]{points1, }
\item[{Vector$<$ Point2f $>$}]{points2}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a245346dbef63e13807c5cd9160803d25}


It performs the chierality test\+: given a couple of rotation matrices, translation vectors and matches it finds the correct rotation and translation s.\+t. 

the triangulated points have their depth coordinates greater than 0. The method is used by essential\+Decomposition, indeed an essential matrix generates 2 rotations and 2 translation. The chierality test is needed in order to discard wrong rototranslations. 
\begin{DoxyParams}{Parameters}
{\em R1} & first rotation 3x3 matrix \\
\hline
{\em R2} & second rotation 3x3 matrix \\
\hline
{\em t1} & first translation 3x1 matrix \\
\hline
{\em t2} & second translation 3x1 matrix \\
\hline
{\em R} & output rotation matrix \\
\hline
{\em t} & output translation matrix \\
\hline
{\em points1} & corrispondences in the first image \\
\hline
{\em points2} & corrispondences in the second image \\
\hline
\end{DoxyParams}


Definition at line 991 of file stereo\+Camera.\+cpp.



References triangulation().



Referenced by essential\+Decomposition().


\begin{DoxyCode}
991                                                                                                            
                                 \{
992 
993         Mat A= Mat::eye(3,4,CV\_64FC1);
994         Mat P1 = this->Kleft*Mat::eye(3, 4, CV\_64F);
995 
996         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < R1.rows; i++)
997          \{
998              \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
999              \textcolor{keywordtype}{double}* MRi = R1.ptr<\textcolor{keywordtype}{double}>(i);
1000                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < R1.cols; j++)
1001                      Mi[j]=MRi[j];
1002          \}
1003          
1004         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < t1.rows; i++)
1005          \{
1006              \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
1007              \textcolor{keywordtype}{double}* MRi = t1.ptr<\textcolor{keywordtype}{double}>(i);
1008              Mi[3]=MRi[0];
1009          \}
1010 
1011         Mat P2=this->Kright*A;
1012         A= Mat::eye(3,4,CV\_64FC1);
1013         
1014         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < R2.rows; i++)
1015          \{
1016              \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
1017              \textcolor{keywordtype}{double}* MRi = R2.ptr<\textcolor{keywordtype}{double}>(i);
1018                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < R2.cols; j++)
1019                      Mi[j]=MRi[j];
1020          \}
1021         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < t2.rows; i++)
1022          \{
1023              \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
1024              \textcolor{keywordtype}{double}* MRi = t2.ptr<\textcolor{keywordtype}{double}>(i);
1025              Mi[3]=MRi[0];
1026          \}
1027         Mat P3=this->Kright*A;
1028         A= Mat::eye(3,4,CV\_64FC1);
1029 
1030         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < R1.rows; i++)
1031          \{
1032              \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
1033              \textcolor{keywordtype}{double}* MRi = R1.ptr<\textcolor{keywordtype}{double}>(i);
1034              \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < R1.cols; j++)
1035                      Mi[j]=MRi[j];
1036          \}
1037         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < t1.rows; i++)
1038          \{
1039              \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
1040              \textcolor{keywordtype}{double}* MRi = t2.ptr<\textcolor{keywordtype}{double}>(i);
1041              Mi[3]=MRi[0];
1042          \}
1043         Mat P4=this->Kright*A;
1044         A= Mat::eye(3,4,CV\_64FC1);
1045 
1046 
1047             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < R2.rows; i++)
1048      \{
1049          \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
1050          \textcolor{keywordtype}{double}* MRi = R2.ptr<\textcolor{keywordtype}{double}>(i);
1051             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j = 0; j < R2.cols; j++)
1052                  Mi[j]=MRi[j];
1053      \}
1054     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < t2.rows; i++)
1055      \{
1056          \textcolor{keywordtype}{double}* Mi = A.ptr<\textcolor{keywordtype}{double}>(i);
1057          \textcolor{keywordtype}{double}* MRi = t1.ptr<\textcolor{keywordtype}{double}>(i);
1058          Mi[3]=MRi[0];
1059      \}
1060      Mat P5=this->Kright*A;
1061 
1062      \textcolor{keywordtype}{int} err1=0; \textcolor{comment}{//R1 t1}
1063      \textcolor{keywordtype}{int} err2=0; \textcolor{comment}{//R2 t2}
1064      \textcolor{keywordtype}{int} err3=0; \textcolor{comment}{//R1 t2}
1065      \textcolor{keywordtype}{int} err4=0; \textcolor{comment}{//R2 t1}
1066      Mat point(4,1,CV\_64FC1);
1067 
1068          \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<(int) InliersL.size(); i++) 
1069          \{
1070              Point3f point3D=triangulation(points1[i],points2[i],P1,P2);
1071              Mat H1=buildRotTras(R1,t1);
1072              point.at<\textcolor{keywordtype}{double}>(0,0)=point3D.x;
1073              point.at<\textcolor{keywordtype}{double}>(1,0)=point3D.y;
1074              point.at<\textcolor{keywordtype}{double}>(2,0)=point3D.z;
1075              point.at<\textcolor{keywordtype}{double}>(0,0)=1.0;
1076              Mat rotatedPoint=H1*point;
1077 
1078              \textcolor{comment}{//fprintf(stdout, "Camera P2 Point3D: %f %f %f Rotated Point: %f %f %f \(\backslash\)n",
       point3D.x,point3D.y,point3D.z, rotatedPoint.at<double>(0,0),rotatedPoint.at<double>(1,0),rotatedPoint.at<double>(2,0));}
1079 
1080              \textcolor{keywordflow}{if}(point3D.z<0 || rotatedPoint.at<\textcolor{keywordtype}{double}>(2,0)<0) \{
1081                  err1++;                 
1082              \}
1083              point3D=triangulation(points1[i],points2[i],P1,P3);
1084              Mat H2=buildRotTras(R2,t2);
1085              point.at<\textcolor{keywordtype}{double}>(0,0)=point3D.x;
1086              point.at<\textcolor{keywordtype}{double}>(1,0)=point3D.y;
1087              point.at<\textcolor{keywordtype}{double}>(2,0)=point3D.z;
1088              point.at<\textcolor{keywordtype}{double}>(0,0)=1.0;
1089              rotatedPoint=H2*point;  
1090              \textcolor{comment}{//fprintf(stdout, "Camera P3 Point3D: %f %f %f Rotated Point: %f %f %f \(\backslash\)n",
       point3D.x,point3D.y,point3D.z, rotatedPoint.at<double>(0,0),rotatedPoint.at<double>(1,0),rotatedPoint.at<double>(2,0));}
1091 
1092              \textcolor{keywordflow}{if}(point3D.z<0 || rotatedPoint.at<\textcolor{keywordtype}{double}>(2,0)<0) \{
1093                  err2++;                 
1094              \}
1095                           
1096              point3D=triangulation(points1[i],points2[i],P1,P4);   
1097              Mat H3=buildRotTras(R1,t2);
1098              point.at<\textcolor{keywordtype}{double}>(0,0)=point3D.x;
1099              point.at<\textcolor{keywordtype}{double}>(1,0)=point3D.y;
1100              point.at<\textcolor{keywordtype}{double}>(2,0)=point3D.z;
1101              point.at<\textcolor{keywordtype}{double}>(0,0)=1.0;
1102              rotatedPoint=H3*point;
1103              \textcolor{comment}{//fprintf(stdout, "Camera P4 Point3D: %f %f %f Rotated Point: %f %f %f \(\backslash\)n",
       point3D.x,point3D.y,point3D.z, rotatedPoint.at<double>(0,0),rotatedPoint.at<double>(1,0),rotatedPoint.at<double>(2,0));}
1104 
1105              \textcolor{keywordflow}{if}(point3D.z<0 || rotatedPoint.at<\textcolor{keywordtype}{double}>(2,0)<0) \{
1106                  err3++;                 
1107              \} 
1108              
1109              point3D=triangulation(points1[i],points2[i],P1,P5);
1110              Mat H4=buildRotTras(R2,t1);
1111              point.at<\textcolor{keywordtype}{double}>(0,0)=point3D.x;
1112              point.at<\textcolor{keywordtype}{double}>(1,0)=point3D.y;
1113              point.at<\textcolor{keywordtype}{double}>(2,0)=point3D.z;
1114              point.at<\textcolor{keywordtype}{double}>(0,0)=1.0;
1115              rotatedPoint=H4*point;
1116              \textcolor{comment}{//fprintf(stdout, "Camera P5 Point3D: %f %f %f Rotated Point: %f %f %f \(\backslash\)n",
       point3D.x,point3D.y,point3D.z, rotatedPoint.at<double>(0,0),rotatedPoint.at<double>(1,0),rotatedPoint.at<double>(2,0));}
1117              
1118              \textcolor{keywordflow}{if}(point3D.z<0 || rotatedPoint.at<\textcolor{keywordtype}{double}>(2,0)<0) \{
1119                  err4++;                 
1120              \} 
1121 
1122          \}
1123 
1124     \textcolor{comment}{/*printMatrix(R1);}
1125 \textcolor{comment}{    printMatrix(t1);}
1126 \textcolor{comment}{    printMatrix(R2);}
1127 \textcolor{comment}{    printMatrix(t2);*/}
1128     \textcolor{comment}{//fprintf(stdout, "Inliers: %d, %d, \(\backslash\)n",points1.size(),points2.size());}
1129     \textcolor{comment}{//fprintf(stdout, "errors: %d, %d, %d, %d, \(\backslash\)n",err1,err2,err3,err4);}
1130 
1131       \textcolor{keywordtype}{double} minErr=10000;
1132       \textcolor{keywordtype}{double} secondErr=minErr;
1133 
1134       \textcolor{keywordtype}{int} idx=0;
1135       \textcolor{keywordflow}{if}(err1<minErr && t1.ptr<\textcolor{keywordtype}{double}>(0)[0]<0)
1136       \{
1137         idx=1;
1138         secondErr=minErr;
1139         minErr=err1;
1140       \}
1141         
1142       \textcolor{keywordflow}{if}(err2<minErr && t2.ptr<\textcolor{keywordtype}{double}>(0)[0]<0)
1143       \{
1144         idx=2;
1145         secondErr=minErr;
1146         minErr=err2;
1147       \} 
1148       \textcolor{keywordflow}{if}(err3<minErr && t2.ptr<\textcolor{keywordtype}{double}>(0)[0]<0)
1149       \{
1150         idx=3;
1151         secondErr=minErr;
1152         minErr=err3;
1153       \}
1154       \textcolor{keywordflow}{if}(err4<minErr && t1.ptr<\textcolor{keywordtype}{double}>(0)[0]<0)
1155       \{
1156         idx=4;
1157         secondErr=minErr;
1158         minErr=err4;
1159       \}
1160 
1161       \textcolor{comment}{/*if(secondErr==minErr)}
1162 \textcolor{comment}{      \{}
1163 \textcolor{comment}{        R=this->R;}
1164 \textcolor{comment}{        t=this->T;}
1165 \textcolor{comment}{        return;      }
1166 \textcolor{comment}{      \}*/}
1167       \textcolor{keywordflow}{if}(idx==1) \{
1168             R=R1;
1169             t=t1;
1170             \textcolor{keywordflow}{return};
1171        \}
1172       \textcolor{keywordflow}{if}(idx==2) \{
1173             R=R2;
1174             t=t2;
1175             \textcolor{keywordflow}{return};
1176        \}
1177       \textcolor{keywordflow}{if}(idx==3) \{
1178             R=R1;
1179             t=t2;
1180             \textcolor{keywordflow}{return};
1181        \}
1182       \textcolor{keywordflow}{if}(idx==4) \{
1183             R=R2;
1184             t=t1;
1185             \textcolor{keywordflow}{return};
1186        \}
1187 
1188 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!compute\+Disparity@{compute\+Disparity}}
\index{compute\+Disparity@{compute\+Disparity}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{compute\+Disparity}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::compute\+Disparity (
\begin{DoxyParamCaption}
\item[{bool}]{best = {\ttfamily true}, }
\item[{int}]{uniqueness\+Ratio = {\ttfamily 15}, }
\item[{int}]{speckle\+Window\+Size = {\ttfamily 50}, }
\item[{int}]{speckle\+Range = {\ttfamily 16}, }
\item[{int}]{number\+Of\+Disparities = {\ttfamily 64}, }
\item[{int}]{S\+A\+D\+Window\+Size = {\ttfamily 7}, }
\item[{int}]{min\+Disparity = {\ttfamily 0}, }
\item[{int}]{pre\+Filter\+Cap = {\ttfamily 63}, }
\item[{int}]{disp12\+Max\+Diff = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a79e986f2970bb2c5b5acd1ede65984aa}


It computes the Disparity Map using H. 

Hirschmuller Algorithm (C\+V\+P\+R 2006) (see stereo\+Disparity). 
\begin{DoxyParams}{Parameters}
{\em best} & set equal true for better accuracy, equal false for save computation. \\
\hline
{\em uniqueness\+Ratio} & The margin in percents by which the best (minimum) computed cost function value should win the second best value to consider the found match correct. Normally, some value within 5-\/15 range is good enough. \\
\hline
{\em speckle\+Window\+Size} & Maximum size of smooth disparity regions to consider them noise speckles and invdalidate. Set it to 0 to disable speckle filtering. Otherwise, set it somewhere in 50-\/200 range. \\
\hline
{\em speckle\+Range} & Maximum disparity variation within each connected component. If you do speckle filtering, set it to some positive value, multiple of 16. Normally, 16 or 32 is good enough. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
Run the calibration or set all the parameters before using this method. 
\end{DoxyNote}


Definition at line 442 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
445 \{
446     \textcolor{keywordflow}{if} (this->Kleft.empty() || this->DistL.empty() || this->Kright.empty() || this->DistR.empty())
447     \{
448         cout <<\textcolor{stringliteral}{" Cameras are not calibrated! Run the Calibration first!"} << endl;
449         \textcolor{keywordflow}{return};
450     \}
451 
452     \textcolor{keywordflow}{if} (this->imleft.empty() || this->imright.empty())
453     \{
454         cout << \textcolor{stringliteral}{"Images are not set! set the images first!"} << endl;
455         \textcolor{keywordflow}{return};
456     \}
457 
458     Size img\_size=this->imleft.size();
459 
460     StereoSGBM sgbm;
461 
462     \textcolor{keywordflow}{if} (cameraChanged)
463     \{
464         mutex->wait();
465         stereoRectify(this->Kleft, this->DistL, this->Kright, this->DistR, img\_size,
466                       this->R, this->T, this->RLrect, this->RRrect, this->PLrect,
467                       this->PRrect, this->Q, -1);
468 
469         \textcolor{keywordflow}{if} (!rectify)
470         \{
471             this->RLrect=Mat::eye(3,3,CV\_32FC1);
472             this->RRrect=Mat::eye(3,3,CV\_32FC1);
473             this->PLrect=this->Kleft;
474             this->PRrect=this->Kright;
475         \}
476         mutex->post();
477     \}
478 
479     \textcolor{keywordflow}{if} (cameraChanged)
480     \{
481         initUndistortRectifyMap(this->Kleft, this->DistL, this->RLrect, this->PLrect,
482                                 img\_size, CV\_32FC1, this->map11, this->map12);
483         initUndistortRectifyMap(this->Kright,  this->DistR, this->RRrect, this->PRrect,
484                                 img\_size, CV\_32FC1, this->map21, this->map22);
485     \}
486     
487     Mat img1r, img2r;
488     remap(this->imleft, img1r, this->map11, this->map12, cv::INTER\_LINEAR);
489     remap(this->imright, img2r, this->map21,this->map22, cv::INTER\_LINEAR);
490   
491     sgbm.preFilterCap=preFilterCap; \textcolor{comment}{//63}
492     sgbm.SADWindowSize=SADWindowSize;
493     \textcolor{keywordtype}{int} cn=this->imleft.channels();
494     sgbm.P1=8*cn*sgbm.SADWindowSize*sgbm.SADWindowSize;
495     sgbm.P2=32*cn*sgbm.SADWindowSize*sgbm.SADWindowSize;
496     sgbm.minDisparity=minDisparity; \textcolor{comment}{//-15}
497     sgbm.numberOfDisparities=numberOfDisparities;
498     sgbm.uniquenessRatio=uniquenessRatio; \textcolor{comment}{//22}
499     sgbm.speckleWindowSize=speckleWindowSize; \textcolor{comment}{//100}
500     sgbm.speckleRange=speckleRange; \textcolor{comment}{//32}
501     sgbm.disp12MaxDiff=disp12MaxDiff;
502     sgbm.fullDP=best; \textcolor{comment}{// alg == STEREO\_HH}
503     
504     Mat disp,disp8,map,dispTemp;
505     sgbm(img1r,img2r,disp);
506 
507     disp.convertTo(map, CV\_32FC1, 1.0,0.0);
508     map.convertTo(map,CV\_32FC1,255/(numberOfDisparities*16.));
509     \textcolor{comment}{//normalize(map,map, 0, 255, cv::NORM\_MINMAX, CV\_8UC1);}
510     
511     \textcolor{keywordflow}{if} (cameraChanged)
512     \{
513         this->mutex->wait();
514         Mat inverseMapL(map.rows*map.cols,1,CV\_32FC2);
515         Mat inverseMapR(map.rows*map.cols,1,CV\_32FC2);
516 
517         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} y=0; y<map.rows; y++)
518         \{
519             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} x=0; x<map.cols; x++)
520             \{
521                 inverseMapL.ptr<\textcolor{keywordtype}{float}>(y*map.cols+x)[0]=(\textcolor{keywordtype}{float})x;
522                 inverseMapL.ptr<\textcolor{keywordtype}{float}>(y*map.cols+x)[1]=(\textcolor{keywordtype}{float})y;
523                 inverseMapR.ptr<\textcolor{keywordtype}{float}>(y*map.cols+x)[0]=(\textcolor{keywordtype}{float})x;
524                 inverseMapR.ptr<\textcolor{keywordtype}{float}>(y*map.cols+x)[1]=(\textcolor{keywordtype}{float})y;
525             \}
526         \}
527 
528         undistortPoints(inverseMapL,inverseMapL,this->Kleft,this->DistL,this->RLrect,this->PLrect);
529         undistortPoints(inverseMapR,inverseMapR,this->Kright,this->DistR,this->RRrect,this->PRrect);
530 
531         Mat mapperL=inverseMapL.reshape(2,map.rows);
532         Mat mapperR=inverseMapR.reshape(2,map.rows);
533         this->MapperL=mapperL;
534         this->MapperR=mapperR;
535         this->mutex->post();
536         cameraChanged=false;
537     \}
538 
539     Mat x;
540     remap(map,dispTemp,this->MapperL,x,cv::INTER\_LINEAR);
541     dispTemp.convertTo(disp8,CV\_8U); 
542 
543     this->mutex->wait();
544     this->Disparity=disp8;
545     this->Disparity16=disp;
546     this->mutex->post();
547 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!compute\+World\+Image@{compute\+World\+Image}}
\index{compute\+World\+Image@{compute\+World\+Image}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{compute\+World\+Image}]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::compute\+World\+Image (
\begin{DoxyParamCaption}
\item[{Mat \&}]{H}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a52ef2f3401488e5c4fa6badd1336f96d}


The method returns a 3-\/\+Channels float image with the world coordinates w.\+r.\+t H reference system. 


\begin{DoxyParams}{Parameters}
{\em H} & the transformation from the camera reference system to the H reference system \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The 3-\/\+Channels float image with the world coordinates w.\+r.\+t H reference system. 
\end{DoxyReturn}


Definition at line 2088 of file stereo\+Camera.\+cpp.



References get\+R\+Lrect().


\begin{DoxyCode}
2089 \{
2090 
2091     Mat worldImg(Disparity16.rows,Disparity16.cols,CV\_32FC3);
2092 
2093     \textcolor{keywordflow}{if}(H.empty())
2094         H=H.eye(4,4,CV\_64FC1);
2095 
2096     \textcolor{keywordflow}{if}(Disparity16.empty() || MapperL.empty() || Q.empty())
2097     \{
2098         cout <<\textcolor{stringliteral}{" Run computeDisparity() method first"} << endl;
2099         \textcolor{keywordflow}{return} worldImg;
2100     \}
2101 
2102 
2103     Mat dispTemp;
2104     Mat x;
2105     remap(this->Disparity16,dispTemp,this->MapperL,x,cv::INTER\_LINEAR);
2106     reprojectImageTo3D(dispTemp, worldImg,this->Q,\textcolor{keyword}{true});
2107 
2108     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<worldImg.rows; i++)
2109     \{
2110        \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<worldImg.cols; j++)
2111         \{   
2112             Mat RLrectTmp=this->getRLrect().t();
2113             Mat Tfake = Mat::zeros(0,3,CV\_64F);
2114             Mat P(4,1,CV\_64FC1);
2115             \textcolor{keywordflow}{if}((worldImg.data + worldImg.step * i)[j * worldImg.channels() + 2]>100)
2116             \{
2117                 P.at<\textcolor{keywordtype}{double}>(0,0)=0.0;
2118                 P.at<\textcolor{keywordtype}{double}>(1,0)=0.0;
2119                 P.at<\textcolor{keywordtype}{double}>(2,0)=0.0;
2120                 P.at<\textcolor{keywordtype}{double}>(3,0)=1.0;
2121             \}
2122             \textcolor{keywordflow}{else}
2123             \{
2124                 P.at<\textcolor{keywordtype}{double}>(0,0)=(worldImg.data + worldImg.step * i)[j * worldImg.channels() + 0];
2125                 P.at<\textcolor{keywordtype}{double}>(1,0)=(worldImg.data + worldImg.step * i)[j * worldImg.channels() + 1];
2126                 P.at<\textcolor{keywordtype}{double}>(2,0)=(worldImg.data + worldImg.step * i)[j * worldImg.channels() + 2];
2127                 P.at<\textcolor{keywordtype}{double}>(3,0)=1;
2128 
2129                 Mat Hrect=buildRotTras(RLrectTmp,Tfake);
2130                 P=H*Hrect*P;
2131             \}
2132             (worldImg.data + worldImg.step * i)[j * worldImg.channels() + 0]=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(
      0,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2133             (worldImg.data + worldImg.step * i)[j * worldImg.channels() + 1]=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(
      1,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2134             (worldImg.data + worldImg.step * i)[j * worldImg.channels() + 2]=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(
      2,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2135         \}
2136     \}
2137     
2138     \textcolor{keywordflow}{return} worldImg;
2139 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!draw\+Matches@{draw\+Matches}}
\index{draw\+Matches@{draw\+Matches}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{draw\+Matches}]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::draw\+Matches (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a6580ff03c7cec5c385ec717f9c018e21}


The method returns a 3-\/\+Channels 8bit image with the image matches. 

\begin{DoxyReturn}{Returns}
The 3-\/\+Channels 8bit image with the image matches. Call \hyperlink{classStereoCamera_aeb1cf4e41058cd70c7df6b8c2511548d}{find\+Match()} to retrieve the keypoints first. 
\end{DoxyReturn}


Definition at line 1511 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1512 \{
1513     \textcolor{keywordflow}{if} (this->imleftund.empty() || this->imrightund.empty())
1514     \{
1515         imleftund=imleft;
1516         imrightund=imright;
1517     \}
1518 
1519     Mat matchImg;
1520     vector<KeyPoint> keypoints1(InliersL.size());
1521     vector<KeyPoint> keypoints2(InliersL.size());
1522     vector<DMatch> filteredMatches(InliersL.size());
1523 
1524     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<InliersL.size(); i++)
1525     \{
1526         filteredMatches[i].queryIdx=i;
1527         filteredMatches[i].trainIdx=i;
1528 
1529         keypoints1[i]=cv::KeyPoint(InliersL[i],2);
1530         keypoints2[i]=cv::KeyPoint(InliersR[i],2);
1531     \}
1532 
1533     cv::drawMatches(this->imleftund,keypoints1,this->imrightund,keypoints2,
1534                     filteredMatches,matchImg,Scalar(0,0,255,0),Scalar(0,0,255,0));
1535 
1536     \textcolor{keywordflow}{return} matchImg;
1537 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!essential\+Decomposition@{essential\+Decomposition}}
\index{essential\+Decomposition@{essential\+Decomposition}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{essential\+Decomposition}]{\setlength{\rightskip}{0pt plus 5cm}bool Stereo\+Camera\+::essential\+Decomposition (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a180388e93b654802c7c56c18d206214b}


It decomposes the essential matrix in Rotation and Translation between the two views. 

The output is stored in the private members R and T. 

Definition at line 894 of file stereo\+Camera.\+cpp.



References chierality().


\begin{DoxyCode}
895 \{
896     \textcolor{keywordflow}{if} (E.empty())
897     \{
898         cout << \textcolor{stringliteral}{"Essential Matrix is empty! Run the estimateEssential first!"} << endl;
899         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
900     \}
901     
902     \textcolor{keywordflow}{if} (this->InliersL.empty())
903     \{
904         cout << \textcolor{stringliteral}{"No matches in memory! Run findMatch first!"} << endl;
905         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
906     \}
907 
908     Mat W=Mat(3,3,CV\_64FC1);
909     W.setTo(0);
910     W.at<\textcolor{keywordtype}{double}>(0,0)=0;
911     W.at<\textcolor{keywordtype}{double}>(0,1)=-1;
912     W.at<\textcolor{keywordtype}{double}>(0,2)=0;
913 
914     W.at<\textcolor{keywordtype}{double}>(1,0)=1;
915     W.at<\textcolor{keywordtype}{double}>(1,1)=0;
916     W.at<\textcolor{keywordtype}{double}>(1,2)=0;
917 
918     W.at<\textcolor{keywordtype}{double}>(2,0)=0;
919     W.at<\textcolor{keywordtype}{double}>(2,1)=0;
920     W.at<\textcolor{keywordtype}{double}>(2,2)=1;
921 
922     SVD dec(E);
923     
924     Mat Y=Mat::eye(3,3,CV\_64FC1);
925     Y.at<\textcolor{keywordtype}{double}>(2,2)=0.0;
926     E=dec.u*Y*dec.vt; \textcolor{comment}{// projection to the Essential Matrix space}
927     
928     dec(E);
929 
930     Mat V=dec.vt;
931     Mat U=dec.u;
932 
933     Mat R1=U*W*V;
934     Mat R2=U*W.t()*V;
935     
936     \textcolor{keywordflow}{if} (determinant(R1)<0 || determinant(R2)<0)
937     \{
938         E=-E;
939         SVD dec2(E);
940 
941         V=dec2.vt;
942         U=dec2.u;
943         
944         R1=U*W*V;
945         R2=U*W.t()*V;
946     \}
947 
948     Mat t1=U(Range(0,3),Range(2,3));
949     Mat t2=-t1;
950 
951     Mat Rnew=Mat(3,3,CV\_64FC1);
952     Rnew.setTo(0);
953     Mat tnew=Mat(3,1,CV\_64FC1);
954 
955     chierality(R1,R2,t1,t2,Rnew,tnew,this->InliersL,this->InliersR);
956     
957     \textcolor{comment}{//double t\_norm=norm(T/norm(T),tnew/norm(tnew));}
958     \textcolor{comment}{//double r\_norm=norm(R,Rnew);}
959     
960     Mat rvec\_new=Mat::zeros(3,1,CV\_64FC1);
961     Mat rvec\_exp=Mat::zeros(3,1,CV\_64FC1);
962     Rodrigues(Rnew,rvec\_new);
963     Rodrigues(R\_exp,rvec\_exp);
964 
965     Mat t\_est=(tnew/norm(tnew))*norm(this->T);
966     
967     Mat diff\_angles=rvec\_exp-rvec\_new;
968     Mat diff\_tran=T\_exp-t\_est;
969     
970     fprintf(stdout,\textcolor{stringliteral}{"Angles Differences: %f %f %f\(\backslash\)n"},diff\_angles.at<\textcolor{keywordtype}{double}>(0,0),diff\_angles.at<\textcolor{keywordtype}{double}>(1,0)
      ,diff\_angles.at<\textcolor{keywordtype}{double}>(2,0));
971     fprintf(stdout,\textcolor{stringliteral}{"Translation Differences: %f %f %f\(\backslash\)n"},diff\_tran.at<\textcolor{keywordtype}{double}>(0,0),diff\_tran.at<\textcolor{keywordtype}{double}>(1,0
      ),diff\_tran.at<\textcolor{keywordtype}{double}>(2,0));    
972     
973     \textcolor{comment}{// Magic numbers: rvec\_new are the rotation angles, only vergence (rvec\_new(1,0)) is allowed to be
       large}
974     \textcolor{comment}{// t\_est is the translation estimated, it can change a little bit when joint 4 of the head is moving}
975     \textcolor{keywordflow}{if} (fabs(diff\_angles.at<\textcolor{keywordtype}{double}>(0,0))<0.15 && fabs(diff\_angles.at<\textcolor{keywordtype}{double}>(1,0))<0.15 && fabs(
      diff\_angles.at<\textcolor{keywordtype}{double}>(2,0))<0.15 &&
976         fabs(diff\_tran.at<\textcolor{keywordtype}{double}>(0,0))<0.01 && fabs(diff\_tran.at<\textcolor{keywordtype}{double}>(1,0))<0.01  && fabs(diff\_tran.at<\textcolor{keywordtype}{
      double}>(2,0))<0.01)    
977     \{
978         this->mutex->wait();
979         this->R=Rnew;
980         this->T=t\_est;
981         this->updatePMatrix();
982         this->cameraChanged=\textcolor{keyword}{true};
983         this->mutex->post();
984         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
985     \}
986     \textcolor{keywordflow}{else}
987         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
988 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!estimate\+Essential@{estimate\+Essential}}
\index{estimate\+Essential@{estimate\+Essential}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{estimate\+Essential}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::estimate\+Essential (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_ab2eded08bca185ac22cd6343cb4c85c8}


It estimates the essential matrix (3x3) E between two views. 

The output is stored in the private member E. 

Definition at line 788 of file stereo\+Camera.\+cpp.



References Ffrom\+P().


\begin{DoxyCode}
789 \{
790     this->InliersL.clear();
791     this->InliersR.clear();
792 
793     \textcolor{keywordflow}{if} (this->PointsL.size()<10 || this->PointsL.size()<10 )
794     \{
795         cout << \textcolor{stringliteral}{"Not enough matches in memory! Run findMatch first!"} << endl;
796         this->E=Mat(3,3,CV\_64FC1);
797         \textcolor{keywordflow}{return};
798     \}
799 
800     updateExpectedCameraMatrices();
801     Mat F\_exp=FfromP(Pleft\_exp,Pright\_exp);
802 
803     vector<Point2f> filteredL;
804     vector<Point2f> filteredR;
805 
806     fprintf(stdout,\textcolor{stringliteral}{"%lu Match Found \(\backslash\)n"},PointsR.size());
807     Mat pl=Mat(3,1,CV\_64FC1);
808     Mat pr=Mat(3,1,CV\_64FC1);
809 
810     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i=0; i<(int) PointsL.size(); i++)
811     \{
812         pl.at<\textcolor{keywordtype}{double}>(0,0)=PointsL[i].x;
813         pl.at<\textcolor{keywordtype}{double}>(1,0)=PointsL[i].y;
814         pl.at<\textcolor{keywordtype}{double}>(2,0)=1;
815         
816         pr.at<\textcolor{keywordtype}{double}>(0,0)=PointsR[i].x;
817         pr.at<\textcolor{keywordtype}{double}>(1,0)=PointsR[i].y;
818         pr.at<\textcolor{keywordtype}{double}>(2,0)=1;
819              
820         Mat xrFxl=pr.t()*F\_exp*pl;
821         Mat Fxl=F\_exp*pl;
822         Mat Fxr=F\_exp.t()*pr;
823 
824         pow(xrFxl,2,xrFxl);
825 
826         pow(Fxl,2,Fxl);
827 
828         pow(Fxr,2,Fxr);
829         
830         Scalar den1,den2;
831         den1=sum(Fxl);
832         den2=sum(Fxr);
833         \textcolor{keywordtype}{double} sampsonDistance=xrFxl.at<\textcolor{keywordtype}{double}>(0,0)/(den1.val[0]+den2.val[0]);
834         
835         \textcolor{keywordflow}{if} (sampsonDistance<0.1)
836         \{
837             filteredL.push\_back(PointsL[i]);
838             filteredR.push\_back(PointsR[i]);
839         \}
840     \}
841 
842     fprintf(stdout,\textcolor{stringliteral}{"%lu Match After Kinematics Filtering \(\backslash\)n"},filteredL.size());
843 
844     vector<uchar> status;
845     this->F=findFundamentalMat(Mat(filteredL), Mat(filteredR),status, CV\_FM\_8POINT, 1, 0.999);
846     
847     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i=0; i<(int) filteredL.size(); i++)
848     \{
849         pl.at<\textcolor{keywordtype}{double}>(0,0)=filteredL[i].x;
850         pl.at<\textcolor{keywordtype}{double}>(1,0)=filteredL[i].y;
851         pl.at<\textcolor{keywordtype}{double}>(2,0)=1;
852         
853         pr.at<\textcolor{keywordtype}{double}>(0,0)=filteredR[i].x;
854         pr.at<\textcolor{keywordtype}{double}>(1,0)=filteredR[i].y;
855         pr.at<\textcolor{keywordtype}{double}>(2,0)=1;
856              
857         Mat xrFxl=pr.t()*F*pl;
858         Mat Fxl=F*pl;
859         Mat Fxr=F.t()*pr;
860 
861         pow(xrFxl,2,xrFxl);
862         pow(Fxl,2,Fxl);
863         pow(Fxr,2,Fxr);
864         
865         Scalar den1,den2;
866         den1=sum(Fxl);
867         den2=sum(Fxr);
868         \textcolor{keywordtype}{double} sampsonDistance=xrFxl.at<\textcolor{keywordtype}{double}>(0,0)/(den1.val[0]+den2.val[0]);
869 
870         \textcolor{keywordflow}{if} (status[i]==1 && xrFxl.at<\textcolor{keywordtype}{double}>(0,0)<0.001) 
871         \{
872             InliersL.push\_back(filteredL[i]);
873             InliersR.push\_back(filteredR[i]);
874         \}
875     \}
876 
877     fprintf(stdout,\textcolor{stringliteral}{"%lu Match After RANSAC Filtering \(\backslash\)n"},InliersL.size());
878 
879     \textcolor{keywordflow}{if} (this->InliersL.size()<10 || this->InliersR.size()<10 )
880     \{
881         InliersL.clear();
882         InliersR.clear();
883         cout << \textcolor{stringliteral}{"Not enough matches in memory! Run findMatch first!"} << endl;
884         this->E=Mat(3,3,CV\_64FC1);
885         \textcolor{keywordflow}{return};
886     \}    
887    
888     this->F=findFundamentalMat(Mat(InliersL), Mat(InliersR),status, CV\_FM\_8POINT, 1, 0.999);
889     this->E=this->Kright.t()*this->F*this->Kleft;
890 
891 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!Ffrom\+P@{Ffrom\+P}}
\index{Ffrom\+P@{Ffrom\+P}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{Ffrom\+P}]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::\+Ffrom\+P (
\begin{DoxyParamCaption}
\item[{Mat \&}]{P1, }
\item[{Mat \&}]{P2}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a3fe4e87322f8644cd21ce06e8522c815}


The function computes the fundamental matrix starting from known camera matrices. 


\begin{DoxyParams}{Parameters}
{\em P1} & a 3x4 matrix representing the camera matrix of the left view. \\
\hline
{\em P2} & a 3x4 matrix representing the camera matrix of the right view. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a 3x3 matrix representing the fundamental matrix. 
\end{DoxyReturn}


Definition at line 706 of file stereo\+Camera.\+cpp.



Referenced by estimate\+Essential().


\begin{DoxyCode}
707 \{
708     Mat F\_true(3,3,CV\_64FC1);
709 
710     Mat X1(2,4,CV\_64FC1);
711     Mat X2(2,4,CV\_64FC1);
712     Mat X3(2,4,CV\_64FC1);
713 
714     Mat Y1(2,4,CV\_64FC1);
715     Mat Y2(2,4,CV\_64FC1);
716     Mat Y3(2,4,CV\_64FC1);
717     
718 
719     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<P1.rows; i++)
720     \{
721         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<P1.cols; j++)
722         \{
723             \textcolor{keywordflow}{if}(i==0)
724             \{
725                 X2.at<\textcolor{keywordtype}{double}>(1,j)= P1.at<\textcolor{keywordtype}{double}>(i,j);
726                 X3.at<\textcolor{keywordtype}{double}>(0,j)= P1.at<\textcolor{keywordtype}{double}>(i,j);
727                 Y2.at<\textcolor{keywordtype}{double}>(1,j)= P2.at<\textcolor{keywordtype}{double}>(i,j);
728                 Y3.at<\textcolor{keywordtype}{double}>(0,j)= P2.at<\textcolor{keywordtype}{double}>(i,j);                    
729             \}
730             \textcolor{keywordflow}{if}(i==1)
731             \{
732                 X1.at<\textcolor{keywordtype}{double}>(0,j)= P1.at<\textcolor{keywordtype}{double}>(i,j);
733                 X3.at<\textcolor{keywordtype}{double}>(1,j)= P1.at<\textcolor{keywordtype}{double}>(i,j);
734                 Y1.at<\textcolor{keywordtype}{double}>(0,j)= P2.at<\textcolor{keywordtype}{double}>(i,j);
735                 Y3.at<\textcolor{keywordtype}{double}>(1,j)= P2.at<\textcolor{keywordtype}{double}>(i,j);                   
736             \}
737 
738             \textcolor{keywordflow}{if}(i==2)
739             \{
740                 X1.at<\textcolor{keywordtype}{double}>(1,j)= P1.at<\textcolor{keywordtype}{double}>(i,j);
741                 X2.at<\textcolor{keywordtype}{double}>(0,j)= P1.at<\textcolor{keywordtype}{double}>(i,j);
742                 Y1.at<\textcolor{keywordtype}{double}>(1,j)= P2.at<\textcolor{keywordtype}{double}>(i,j);
743                 Y2.at<\textcolor{keywordtype}{double}>(0,j)= P2.at<\textcolor{keywordtype}{double}>(i,j);
744 
745             \}
746 
747         \}
748     \}
749 
750 
751 
752     std::vector<Mat> MatX;
753     std::vector<Mat> MatY;
754 
755     MatX.push\_back(X1);
756     MatX.push\_back(X2);
757     MatX.push\_back(X3);
758 
759     MatY.push\_back(Y1);
760     MatY.push\_back(Y2);
761     MatY.push\_back(Y3);
762 
763 
764 
765     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<F\_true.rows; i++)
766     \{
767         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<F\_true.cols; j++)
768         \{
769             Mat X=MatX[i];
770             Mat Y=MatY[j];
771 
772             Mat concatenated;
773 
774             cv::vconcat(X,Y,concatenated);
775 
776             F\_true.at<\textcolor{keywordtype}{double}>(j,i)=cv::determinant(concatenated);
777 
778 
779         \}
780 
781     \}
782 
783 
784     \textcolor{keywordflow}{return} F\_true;
785 
786 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!find\+Match@{find\+Match}}
\index{find\+Match@{find\+Match}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{find\+Match}]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::find\+Match (
\begin{DoxyParamCaption}
\item[{bool}]{visualize = {\ttfamily false}, }
\item[{double}]{displacement = {\ttfamily 20.0}, }
\item[{double}]{radius = {\ttfamily 200.0}}
\end{DoxyParamCaption}
)}\label{classStereoCamera_aeb1cf4e41058cd70c7df6b8c2511548d}


It finds matches between two images. 

S\+I\+F\+T detector and descriptor is used. \begin{DoxyNote}{Note}
Run set\+Images and indistort\+Images methods before using this method. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em visualize} & true if you want to visualize matches between images \\
\hline
{\em displacement} & maximum pixel displacement between first and second camera \\
\hline
{\em radius} & maximum radius between the first candidate match and the second one \\
\hline
\end{DoxyParams}


Definition at line 578 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
579 \{
580     \textcolor{keywordflow}{if} (this->imleftund.empty() || this->imrightund.empty())
581     \{
582         imleftund=imleft;
583         imrightund=imright;
584     \}
585 
586     this->PointsL.clear();
587     this->PointsR.clear();
588     
589     this->InliersL.clear();
590     this->InliersR.clear();
591 
592     Mat grayleft(imleftund.rows,imleftund.cols, CV\_8UC1);
593     imleftund.convertTo(grayleft,CV\_8UC1);
594     
595     Mat grayright(imrightund.rows,imrightund.cols,CV\_8UC1);
596     imrightund.convertTo(grayright,CV\_8UC1);
597     
598     vector<KeyPoint> keypoints1,keypoints2;
599     Mat descriptors1,descriptors2;
600 
601     Ptr<cv::FeatureDetector> detector=cv::FeatureDetector::create(\textcolor{stringliteral}{"SIFT"});
602     Ptr<cv::DescriptorExtractor> descriptorExtractor=cv::DescriptorExtractor::create(\textcolor{stringliteral}{"SIFT"});
603     cv::BFMatcher descriptorMatcher;
604 
605     yAssert(detector!=NULL);
606     yAssert(descriptorExtractor!=NULL);
607 
608     detector->detect(grayleft,keypoints1);
609     descriptorExtractor->compute(grayleft,keypoints1,descriptors1);
610 
611     detector->detect(grayright,keypoints2);
612     descriptorExtractor->compute(grayright,keypoints2,descriptors2);
613 
614     vector<DMatch> filteredMatches;
615     crossCheckMatching(descriptorMatcher,descriptors1,descriptors2,filteredMatches,radius);
616 
617     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i=0; i<filteredMatches.size(); i++)
618     \{
619         Point2f pointL=keypoints1[filteredMatches[i].queryIdx].pt;
620         Point2f pointR=keypoints2[filteredMatches[i].trainIdx].pt;
621         \textcolor{keywordflow}{if} (fabs(pointL.y-pointR.y)<displacement)
622         \{
623             this->PointsR.push\_back(pointR);
624             this->PointsL.push\_back(pointL);
625         \}   
626     \}
627 
628     Mat matchImg;
629     \textcolor{keywordflow}{if} (visualize)
630         cv::drawMatches(this->imleftund,keypoints1,this->imrightund,keypoints2,
631                         filteredMatches,matchImg,Scalar(0,0,255,0),Scalar(0,0,255,0));
632 
633     \textcolor{keywordflow}{return} matchImg;
634 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!from\+Rectified\+To\+Original@{from\+Rectified\+To\+Original}}
\index{from\+Rectified\+To\+Original@{from\+Rectified\+To\+Original}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{from\+Rectified\+To\+Original}]{\setlength{\rightskip}{0pt plus 5cm}Point2f Stereo\+Camera\+::from\+Rectified\+To\+Original (
\begin{DoxyParamCaption}
\item[{int}]{u, }
\item[{int}]{v, }
\item[{int}]{camera}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a3d8fde0cbd4604085b883f22cc606c01}


Given the u,v pixel coordinates in the rectified image the method returns the position of the pixel in the non-\/rectified frame. 


\begin{DoxyParams}{Parameters}
{\em u} & the x pixel coordinate in the rectified image. \\
\hline
{\em v} & the y pixel coordinate in the rectified image. \\
\hline
{\em cam} & cam=1 for left image, cam=2 for right image. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the pixel position in the non-\/rectified image. 
\end{DoxyReturn}


Definition at line 550 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
551 \{
552     cv::Point2f originalPoint;
553 
554 
555     \textcolor{keywordflow}{if}(u>=map11.rows || u<0 || v>=map12.cols || v< 0)
556     \{
557         originalPoint.x=0;
558         originalPoint.y=0;
559         \textcolor{keywordflow}{return} originalPoint;
560     \}
561     \textcolor{keywordflow}{if}(camera==LEFT)
562     \{
563             originalPoint.x=map11.ptr<\textcolor{keywordtype}{float}>(v)[u];
564             originalPoint.y=map12.ptr<\textcolor{keywordtype}{float}>(v)[u];
565     \}
566     \textcolor{keywordflow}{else}
567     \{
568             originalPoint.x=map21.ptr<\textcolor{keywordtype}{float}>(v)[u];
569             originalPoint.y=map22.ptr<\textcolor{keywordtype}{float}>(v)[u];
570     \}
571 
572 
573     \textcolor{keywordflow}{return} originalPoint;
574 
575 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Disparity@{get\+Disparity}}
\index{get\+Disparity@{get\+Disparity}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Disparity}]{\setlength{\rightskip}{0pt plus 5cm}const Mat Stereo\+Camera\+::get\+Disparity (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a97607922d84e1a1a006cd7a5aec93a24}


It returns the disparity image. 

\begin{DoxyReturn}{Returns}
the disparity image computed via \hyperlink{classStereoCamera_a79e986f2970bb2c5b5acd1ede65984aa}{compute\+Disparity()}. The image is 8 bit unsigned. 
\end{DoxyReturn}


Definition at line 397 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
397                                      \{
398     \textcolor{keywordflow}{return} this->Disparity;
399 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Disparity16@{get\+Disparity16}}
\index{get\+Disparity16@{get\+Disparity16}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Disparity16}]{\setlength{\rightskip}{0pt plus 5cm}const Mat Stereo\+Camera\+::get\+Disparity16 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a89f9890f50d85be9ebda7a0769279348}


It returns the disparity image. 

\begin{DoxyReturn}{Returns}
the disparity image computed via \hyperlink{classStereoCamera_a79e986f2970bb2c5b5acd1ede65984aa}{compute\+Disparity()}. The image is 16 bit signed. 
\end{DoxyReturn}


Definition at line 401 of file stereo\+Camera.\+cpp.



Referenced by metric\+Triangulation().


\begin{DoxyCode}
401                                        \{
402     \textcolor{keywordflow}{return} this->Disparity16;
403 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Dist\+Coeff\+Left@{get\+Dist\+Coeff\+Left}}
\index{get\+Dist\+Coeff\+Left@{get\+Dist\+Coeff\+Left}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Dist\+Coeff\+Left}]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+Dist\+Coeff\+Left (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a4830201154ab288bd93f6cceb2c2daf5}


It returns the 5x1 left distortion coefficients. 

\begin{DoxyReturn}{Returns}
5x1 left distortion coefficients. 
\end{DoxyReturn}


Definition at line 2140 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2141 \{
2142     \textcolor{keywordflow}{return} this->DistL;
2143 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Dist\+Coeff\+Right@{get\+Dist\+Coeff\+Right}}
\index{get\+Dist\+Coeff\+Right@{get\+Dist\+Coeff\+Right}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Dist\+Coeff\+Right}]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+Dist\+Coeff\+Right (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a3edeb24b68ee4266f89982533ad1e9bf}


It returns the 5x1 right distortion coefficients. 

\begin{DoxyReturn}{Returns}
5x1 right distortion coefficients. 
\end{DoxyReturn}


Definition at line 2145 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2146 \{
2147     \textcolor{keywordflow}{return} this->DistR;
2148 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Distorted\+Pixel@{get\+Distorted\+Pixel}}
\index{get\+Distorted\+Pixel@{get\+Distorted\+Pixel}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Distorted\+Pixel}]{\setlength{\rightskip}{0pt plus 5cm}Point2f Stereo\+Camera\+::get\+Distorted\+Pixel (
\begin{DoxyParamCaption}
\item[{int}]{u, }
\item[{int}]{v, }
\item[{int}]{cam = {\ttfamily 1}}
\end{DoxyParamCaption}
)}\label{classStereoCamera_af64550bb8a7a665930dee5eea87b7e47}


Given the u,v pixel coordinates in the undistorted image the method returns the original position of the pixel in the distorted frame. 


\begin{DoxyParams}{Parameters}
{\em u} & the x pixel coordinate in the undistorted image. \\
\hline
{\em v} & the y pixel coordinate in the undistorted image. \\
\hline
{\em cam} & cam=1 for left image, cam=2 for right image. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the pixel position in the distorted image. 
\end{DoxyReturn}


Definition at line 2159 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2160 \{
2161     Point2f distortedPixel;
2162     Mat MapperX,MapperY;
2163 
2164     \textcolor{keywordflow}{if}(cam==LEFT)
2165     \{
2166         MapperX=mapxL;
2167         MapperY=mapyL;
2168     \}
2169     \textcolor{keywordflow}{else}
2170     \{
2171         MapperX=mapxR;
2172         MapperY=mapyR;
2173     \}
2174     distortedPixel.x=MapperX.ptr<\textcolor{keywordtype}{float}>(v)[u];
2175     distortedPixel.y=MapperY.ptr<\textcolor{keywordtype}{float}>(v)[u];
2176 
2177     \textcolor{keywordflow}{return} distortedPixel;
2178 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Fundamental@{get\+Fundamental}}
\index{get\+Fundamental@{get\+Fundamental}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Fundamental}]{\setlength{\rightskip}{0pt plus 5cm}const Mat Stereo\+Camera\+::get\+Fundamental (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a257d9f531c444b685a0b96ae3908c2d0}


It returns the 3x3 fundamental matrix. 

\begin{DoxyReturn}{Returns}
3x3 fundamental matrix. 
\end{DoxyReturn}


Definition at line 1343 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1343                                        \{
1344     \textcolor{keywordflow}{return} this->F;
1345 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Im\+Left@{get\+Im\+Left}}
\index{get\+Im\+Left@{get\+Im\+Left}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Im\+Left}]{\setlength{\rightskip}{0pt plus 5cm}const Mat Stereo\+Camera\+::get\+Im\+Left (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a57d155d519c621a7a580f41ec114df01}


It returns the left (first) image. 

\begin{DoxyReturn}{Returns}
the left (first) image. 
\end{DoxyReturn}


Definition at line 388 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
388                                   \{
389 
390     \textcolor{keywordflow}{return} this->imleft;
391 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Im\+Left\+Und@{get\+Im\+Left\+Und}}
\index{get\+Im\+Left\+Und@{get\+Im\+Left\+Und}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Im\+Left\+Und}]{\setlength{\rightskip}{0pt plus 5cm}const Mat Stereo\+Camera\+::get\+Im\+Left\+Und (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a48ff47fc8326d511677bef8bcf3a65bc}


It returns the left undistorted image. 

\begin{DoxyReturn}{Returns}
the left undistorted image. 
\end{DoxyReturn}


Definition at line 1339 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1339                                      \{
1340     \textcolor{keywordflow}{return} this->imleftund;
1341 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Im\+Right@{get\+Im\+Right}}
\index{get\+Im\+Right@{get\+Im\+Right}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Im\+Right}]{\setlength{\rightskip}{0pt plus 5cm}const Mat Stereo\+Camera\+::get\+Im\+Right (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a09e72c3430250883aac6ab5a4d98961f}


It returns the right (second) image. 

\begin{DoxyReturn}{Returns}
the right (second) image. 
\end{DoxyReturn}


Definition at line 393 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
393                                    \{
394     \textcolor{keywordflow}{return} this->imright;
395 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Im\+Right\+Und@{get\+Im\+Right\+Und}}
\index{get\+Im\+Right\+Und@{get\+Im\+Right\+Und}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Im\+Right\+Und}]{\setlength{\rightskip}{0pt plus 5cm}const Mat Stereo\+Camera\+::get\+Im\+Right\+Und (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a0485caf9bd52a7317776e5db495446a5}


It returns the right undistorted image. 

\begin{DoxyReturn}{Returns}
the right undistorted image. 
\end{DoxyReturn}


Definition at line 1347 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1347                                       \{
1348     \textcolor{keywordflow}{return} this->imrightund;
1349 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Kleft@{get\+Kleft}}
\index{get\+Kleft@{get\+Kleft}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Kleft}]{\setlength{\rightskip}{0pt plus 5cm}const Mat Stereo\+Camera\+::get\+Kleft (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a8533ec543166868e3db471bad0cb61a3}


It returns the 3x3 left camera matrix. 

\begin{DoxyReturn}{Returns}
3x3 left camera matrix. 
\end{DoxyReturn}


Definition at line 42 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
42                                  \{
43     \textcolor{keywordflow}{return} this->Kleft;
44 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Kright@{get\+Kright}}
\index{get\+Kright@{get\+Kright}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Kright}]{\setlength{\rightskip}{0pt plus 5cm}const Mat Stereo\+Camera\+::get\+Kright (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a62ea986b40a785e589704bb58750e15b}


It returns the 3x3 right camera matrix. 

\begin{DoxyReturn}{Returns}
3x3 right camera matrix. 
\end{DoxyReturn}


Definition at line 45 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
45                                   \{
46     \textcolor{keywordflow}{return} this->Kright;
47 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+L\+Rectified@{get\+L\+Rectified}}
\index{get\+L\+Rectified@{get\+L\+Rectified}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+L\+Rectified}]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+L\+Rectified (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a0bd4492f7f87862955da0bc5d0042cc8}


The method returns the first rectified image. 

\begin{DoxyReturn}{Returns}
The first rectified image. 
\end{DoxyReturn}


Definition at line 2018 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2019 \{
2020     \textcolor{keywordflow}{return} this->imgLeftRect;
2021 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Mapper\+L@{get\+Mapper\+L}}
\index{get\+Mapper\+L@{get\+Mapper\+L}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Mapper\+L}]{\setlength{\rightskip}{0pt plus 5cm}const Mat Stereo\+Camera\+::get\+Mapper\+L (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a6d7a3361adfda3a05eea2d5116ed2515}


It returns the mapping between the original left camera and the rectified left camera. 

\begin{DoxyReturn}{Returns}
a 16 bit signed 2 channel image containing the mapping from the original left camera to the rectified left camera. 
\end{DoxyReturn}


Definition at line 1752 of file stereo\+Camera.\+cpp.



Referenced by metric\+Triangulation().


\begin{DoxyCode}
1752                                    \{
1753     \textcolor{keywordflow}{return} this->MapperL;
1754 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Mapper\+R@{get\+Mapper\+R}}
\index{get\+Mapper\+R@{get\+Mapper\+R}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Mapper\+R}]{\setlength{\rightskip}{0pt plus 5cm}const Mat Stereo\+Camera\+::get\+Mapper\+R (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a8cbd829aba62360200035bb452edc42b}


It returns the mapping between the original right camera and the rectified right camera. 

\begin{DoxyReturn}{Returns}
a 16 bit signed 2 channel image containing the mapping from the original right camera to the rectified right camera. 
\end{DoxyReturn}


Definition at line 1756 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1756                                    \{
1757     \textcolor{keywordflow}{return} this->MapperR;
1758 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Match\+Left@{get\+Match\+Left}}
\index{get\+Match\+Left@{get\+Match\+Left}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Match\+Left}]{\setlength{\rightskip}{0pt plus 5cm}const vector$<$ Point2f $>$ Stereo\+Camera\+::get\+Match\+Left (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_ac42cf4193f379a3c0ecf5e40c61358f2}


It returns the pixel coordinates of the matches in the left image. 

\begin{DoxyReturn}{Returns}
pixel coordinates of the matches in the left image. 
\end{DoxyReturn}


Definition at line 49 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
49                                                  \{
50     \textcolor{keywordflow}{return} this->InliersL;
51 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Match\+Right@{get\+Match\+Right}}
\index{get\+Match\+Right@{get\+Match\+Right}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Match\+Right}]{\setlength{\rightskip}{0pt plus 5cm}const vector$<$ Point2f $>$ Stereo\+Camera\+::get\+Match\+Right (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_ab35a9b702cd5213bd8d4de8491399201}


It returns the pixel coordinates of the matches in the right image. 

\begin{DoxyReturn}{Returns}
pixel coordinates of the matches in the right image. 
\end{DoxyReturn}


Definition at line 52 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
52                                                    \{
53 
54     \textcolor{keywordflow}{return} this->InliersR;
55 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Q@{get\+Q}}
\index{get\+Q@{get\+Q}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Q}]{\setlength{\rightskip}{0pt plus 5cm}const Mat Stereo\+Camera\+::get\+Q (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a43bd5710058d9ee0ed94dc8b74e5656c}


It returns the 4x4 disparity-\/to-\/depth mapping matrix. 

\begin{DoxyReturn}{Returns}
4x4 disparity-\/to-\/depth mapping matrix. 
\end{DoxyReturn}


Definition at line 404 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
404                              \{
405     \textcolor{keywordflow}{return} this->Q;
406 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+R\+Lrect@{get\+R\+Lrect}}
\index{get\+R\+Lrect@{get\+R\+Lrect}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+R\+Lrect}]{\setlength{\rightskip}{0pt plus 5cm}const Mat Stereo\+Camera\+::get\+R\+Lrect (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a986686c56d4bf5381ea57b3f49338af1}


It returns the rotation matrix between the original left camera and the rectified left camera. 

\begin{DoxyReturn}{Returns}
3x3 rotation matrix between the original left camera and the rectified left camera. 
\end{DoxyReturn}


Definition at line 1744 of file stereo\+Camera.\+cpp.



Referenced by compute\+World\+Image(), metric\+Triangulation(), and triangulate\+Known\+Disparity().


\begin{DoxyCode}
1744                                   \{
1745     \textcolor{keywordflow}{return} this->RLrect;
1746 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Rotation@{get\+Rotation}}
\index{get\+Rotation@{get\+Rotation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Rotation}]{\setlength{\rightskip}{0pt plus 5cm}const Mat Stereo\+Camera\+::get\+Rotation (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a13fc8d5d205e09ab3d1bb8010829b0c1}


It returns the rotation matrix between the two cameras. 

\begin{DoxyReturn}{Returns}
3x3 rotation matrix between the first and the second camera. 
\end{DoxyReturn}


Definition at line 1439 of file stereo\+Camera.\+cpp.



Referenced by horn().


\begin{DoxyCode}
1439                                     \{
1440     \textcolor{keywordflow}{return} this->R;
1441 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+R\+Rectified@{get\+R\+Rectified}}
\index{get\+R\+Rectified@{get\+R\+Rectified}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+R\+Rectified}]{\setlength{\rightskip}{0pt plus 5cm}Mat Stereo\+Camera\+::get\+R\+Rectified (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_aaf4ba8eaa338ff24db1196849a96e5e9}


The method returns the second rectified image. 

\begin{DoxyReturn}{Returns}
The second rectified image. 
\end{DoxyReturn}


Definition at line 2023 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2024 \{
2025     \textcolor{keywordflow}{return} this->imgRightRect;
2026 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+R\+Rrect@{get\+R\+Rrect}}
\index{get\+R\+Rrect@{get\+R\+Rrect}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+R\+Rrect}]{\setlength{\rightskip}{0pt plus 5cm}const Mat Stereo\+Camera\+::get\+R\+Rrect (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a08979926b86d513f1b373109f5a4733d}


It returns the rotation matrix between the original right camera and the rectified right camera. 

\begin{DoxyReturn}{Returns}
3x3 rotation matrix between the original right camera and the rectified right camera. 
\end{DoxyReturn}


Definition at line 1748 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1748                                   \{
1749     \textcolor{keywordflow}{return} this->RRrect;
1750 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!get\+Translation@{get\+Translation}}
\index{get\+Translation@{get\+Translation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{get\+Translation}]{\setlength{\rightskip}{0pt plus 5cm}const Mat Stereo\+Camera\+::get\+Translation (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a7c7df54191a3c73486c0136de18dd52e}


It returns the translation vector between the two cameras. 

\begin{DoxyReturn}{Returns}
3x1 translation matrix between the first and the second camera. 
\end{DoxyReturn}


Definition at line 1435 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1435                                        \{
1436     \textcolor{keywordflow}{return} this->T;
1437 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!horn@{horn}}
\index{horn@{horn}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{horn}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::horn (
\begin{DoxyParamCaption}
\item[{Mat \&}]{K1, }
\item[{Mat \&}]{K2, }
\item[{vector$<$ Point2f $>$ \&}]{Points1, }
\item[{vector$<$ Point2f $>$ \&}]{Points2, }
\item[{Mat \&}]{Rot, }
\item[{Mat \&}]{Tras}
\end{DoxyParamCaption}
)}\label{classStereoCamera_adf155975709fdbf09d3133899d074a02}


It performs the horn relative orientations algorithm i.\+e. 

it estimates the motion from one camera to another one using a initial guess. A good initial guess can be obtained using the essential\+Decomposition method. 
\begin{DoxyParams}{Parameters}
{\em K1} & 3x3 matrix with intrinsic parameters of the first camera \\
\hline
{\em K2} & 3x3 matrix with intrinsic parameters of the second camera \\
\hline
{\em Points1} & matches in the first image \\
\hline
{\em Points2} & matches in the second image \\
\hline
{\em Rot} & initial rotation (3x3 matrix) guess. The new output rotation is stored here \\
\hline
{\em Tras} & initial translation (3x1 matrix) guess. The new output translation is stored here \\
\hline
\end{DoxyParams}


Definition at line 1539 of file stereo\+Camera.\+cpp.



References get\+Rotation().



Referenced by horn\+Relative\+Orientations().


\begin{DoxyCode}
1539                                                                                                            
              \{
1540     \textcolor{keywordtype}{double} prevres = 1E40;
1541     \textcolor{keywordtype}{double} res = 1E39;
1542     \textcolor{keywordtype}{double} vanishing = 1E-16;
1543     Tras=Tras/norm(Tras);
1544 
1545     normalizePoints(K1,K2,PointsL,PointsR);
1546     \textcolor{keywordtype}{int} iters=0;
1547     Mat B(3,3,CV\_64FC1);
1548     Mat C(3,3,CV\_64FC1);
1549     Mat D(3,3,CV\_64FC1);
1550     Mat cs(3,1,CV\_64FC1);
1551     Mat ds(3,1,CV\_64FC1);
1552     Mat r1(3,1,CV\_64FC1);
1553     Mat r2(3,1,CV\_64FC1);
1554 
1555     \textcolor{keywordflow}{while} ( (prevres  - res  >  vanishing) ) \{
1556         iters = iters+1;
1557         
1558         B.setTo(0);
1559         C.setTo(0);
1560         D.setTo(0);
1561         cs.setTo(0);
1562         ds.setTo(0);
1563        
1564         prevres=res;
1565         res=0;
1566         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<(int) PointsL.size(); i++) \{
1567             
1568             r1.at<\textcolor{keywordtype}{double}>(0,0)=PointsL[i].x;
1569             r1.at<\textcolor{keywordtype}{double}>(1,0)=PointsL[i].y;
1570             r1.at<\textcolor{keywordtype}{double}>(2,0)=1;
1571             r1=r1/norm(r1);
1572 
1573             r2.at<\textcolor{keywordtype}{double}>(0,0)=PointsR[i].x;
1574             r2.at<\textcolor{keywordtype}{double}>(1,0)=PointsR[i].y;
1575             r2.at<\textcolor{keywordtype}{double}>(2,0)=1;
1576             r2=r2/norm(r2);
1577 
1578 
1579             Mat r1p= Rot*r1;
1580 
1581             Mat ci=r1p.cross(r2);
1582             Mat di=r1p.cross(r2.cross(Tras));
1583             Mat si=Tras.t()*ci;
1584 
1585           
1586             B=B+(ci*di.t());
1587             D=D+(di*di.t());
1588             C=C+(ci*ci.t());
1589             
1590             cs=cs+ (si.at<\textcolor{keywordtype}{double}>(0,0)*ci);
1591             ds=ds+ (si.at<\textcolor{keywordtype}{double}>(0,0)*di);
1592 
1593             Mat residual=Tras.t()*ci*ci.t()*Tras;
1594             res=res+residual.at<\textcolor{keywordtype}{double}>(0,0);
1595 
1596         \}
1597 
1598         Mat L(7,7,CV\_64FC1);
1599         L.setTo(0);
1600         
1601         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<3; i++)
1602             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<3; j++)
1603                 L.at<\textcolor{keywordtype}{double}>(i,j)=C.at<\textcolor{keywordtype}{double}>(i,j);
1604 
1605         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<3; i++)
1606             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=3; j<6; j++)
1607                 L.at<\textcolor{keywordtype}{double}>(i,j)=B.at<\textcolor{keywordtype}{double}>(i,j-3);
1608     
1609         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<3; i++)
1610                 L.at<\textcolor{keywordtype}{double}>(i,6)=Tras.at<\textcolor{keywordtype}{double}>(i,0);
1611 
1612 
1613         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=3; i<6; i++)
1614             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<3; j++) \{
1615                 Mat Bt=B.t();
1616                 L.at<\textcolor{keywordtype}{double}>(i,j)=Bt.at<\textcolor{keywordtype}{double}>(i-3,j);
1617 
1618             \}
1619 
1620 
1621         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=3; i<6; i++)
1622             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=3; j<6; j++)
1623                 L.at<\textcolor{keywordtype}{double}>(i,j)=D.at<\textcolor{keywordtype}{double}>(i-3,j-3);
1624 
1625         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<3; j++) \{
1626                 Mat Trast=Tras.t();
1627                 L.at<\textcolor{keywordtype}{double}>(6,j)=Trast.at<\textcolor{keywordtype}{double}>(0,j);
1628         \}
1629 
1630 
1631         Mat Y(7,1,CV\_64FC1);
1632         Y.setTo(0);
1633 
1634         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<3; j++)
1635                 Y.at<\textcolor{keywordtype}{double}>(j,0)=-cs.at<\textcolor{keywordtype}{double}>(j,0);
1636 
1637         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=3; j<6; j++)
1638                 Y.at<\textcolor{keywordtype}{double}>(j,0)=-ds.at<\textcolor{keywordtype}{double}>(j-3,0);
1639 
1640         Mat Linv=L.inv();
1641         Mat result=Linv*Y;
1642         Tras=Tras+result(Range(0,3),Range(0,1));
1643         Tras=Tras/norm(Tras);
1644 
1645         Mat q(4,1,CV\_64FC1);
1646 
1647         Mat temp=result(Range(3,6),Range(0,1));       
1648         q.at<\textcolor{keywordtype}{double}>(0,0)= sqrt(1-(0.25* norm(temp)*norm(temp)));
1649         q.at<\textcolor{keywordtype}{double}>(1,0)= 0.5*result.at<\textcolor{keywordtype}{double}>(3,0);
1650         q.at<\textcolor{keywordtype}{double}>(2,0)= 0.5*result.at<\textcolor{keywordtype}{double}>(4,0);
1651         q.at<\textcolor{keywordtype}{double}>(3,0)= 0.5*result.at<\textcolor{keywordtype}{double}>(5,0);
1652 
1653 
1654         Mat deltaR(3,3,CV\_64FC1);
1655         getRotation(q,deltaR);
1656 
1657         Rot=deltaR*Rot;
1658 
1659         SVD dec(Rot);
1660 
1661         Mat Id = Mat::eye(3, 3, CV\_64F);
1662 
1663         Mat Vt=dec.vt;
1664         Mat U=dec.u;
1665 
1666         Rot=U*Id*Vt;
1667     \}
1668 
1669 
1670 
1671 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!horn\+Relative\+Orientations@{horn\+Relative\+Orientations}}
\index{horn\+Relative\+Orientations@{horn\+Relative\+Orientations}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{horn\+Relative\+Orientations}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::horn\+Relative\+Orientations (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a36dae897d07544e8faca8c90216173a6}


It performs the horn relative orientations, all the parameters are assumed initialized in the \hyperlink{classStereoCamera}{Stereo\+Camera} object. 

The new output Rotation and Translation matrices are stored in the R and T members. 

Definition at line 1478 of file stereo\+Camera.\+cpp.



References horn().


\begin{DoxyCode}
1478                                             \{
1479 
1480     \textcolor{keywordflow}{if}(this->PointsL.size()<10 || this->PointsR.size()<10) \{
1481         cout << \textcolor{stringliteral}{"No matches found! Run findMatch fist!"} << endl;
1482         \textcolor{keywordflow}{return};
1483     \}
1484 
1485 
1486     \textcolor{keywordflow}{if}(this->Kleft.empty() || this->Kright.empty() || this->R.empty() || this->T.empty()) \{
1487         cout << \textcolor{stringliteral}{"Cameras are empty, run Calibration first"} << endl;
1488         \textcolor{keywordflow}{return};
1489     \}
1490 
1491     \textcolor{keywordflow}{if}(InliersL.empty()) \{
1492         InliersL=PointsL;
1493         InliersR=PointsR;
1494     \}
1495 
1496     Mat Rot=this->R.clone();
1497     Mat Tras=this->T.clone();
1498     horn(this->Kleft,this->Kright,this->InliersL,this->InliersR,Rot,Tras);
1499 
1500 
1501     this->R=Rot.clone();
1502     this->Rinit=Rot.clone();
1503 
1504     this->T=Tras/norm(Tras)*norm(T);
1505     this->Tinit=Tras/norm(Tras)*norm(Tinit);
1506 
1507     this->updatePMatrix();
1508 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!metric\+Triangulation@{metric\+Triangulation}}
\index{metric\+Triangulation@{metric\+Triangulation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{metric\+Triangulation}]{\setlength{\rightskip}{0pt plus 5cm}Point3f Stereo\+Camera\+::metric\+Triangulation (
\begin{DoxyParamCaption}
\item[{Point2f \&}]{point1, }
\item[{double}]{th\+Meters = {\ttfamily 10}}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a2fcd3e1767bcf04716b0e2ac76098430}


It performs the metric triangulation given the pixel coordinates on the first image. 

Run compute disparity before using this method. 
\begin{DoxyParams}{Parameters}
{\em point1} & the pixel coordinates in the first image. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a metric 3\+D point w.\+r.\+t. the first camera reference system. 
\end{DoxyReturn}


Definition at line 1790 of file stereo\+Camera.\+cpp.



References get\+Disparity16(), and get\+Mapper\+L().


\begin{DoxyCode}
1790                                                                           \{
1791     mutex->wait();
1792 
1793     \textcolor{keywordflow}{if}(Q.empty() || Disparity16.empty()) \{
1794         cout << \textcolor{stringliteral}{"Run computeDisparity() method first!"} << endl;
1795         Point3f point;
1796         point.x=0.0;
1797         point.y=0.0;
1798         point.z=0.0;
1799 
1800         mutex->post();
1801         \textcolor{keywordflow}{return} point;
1802     \}
1803 
1804     \textcolor{keywordtype}{int} u=(int) point1.x; 
1805     \textcolor{keywordtype}{int} v=(\textcolor{keywordtype}{int}) point1.y;
1806     Point3f point;
1807 
1808 
1809     \textcolor{comment}{// Mapping from Rectified Cameras to Original Cameras}
1810     Mat Mapper=this->getMapperL();
1811 
1812     \textcolor{keywordflow}{if}(Mapper.empty()) \{
1813         point.x=0.0;
1814         point.y=0.0;
1815         point.z=0.0;
1816        
1817         mutex->post();
1818         \textcolor{keywordflow}{return} point;
1819     \}
1820 
1821 
1822     \textcolor{keywordtype}{float} usign=Mapper.ptr<\textcolor{keywordtype}{float}>(v)[2*u];
1823     \textcolor{keywordtype}{float} vsign=Mapper.ptr<\textcolor{keywordtype}{float}>(v)[2*u+1]; 
1824 
1825     u=cvRound(usign);
1826     v=cvRound(vsign);
1827 
1828     IplImage disp16=this->getDisparity16();
1829     
1830 
1831     \textcolor{keywordflow}{if}(u<0 || u>=disp16.width || v<0 || v>=disp16.height) \{
1832         point.x=0.0;
1833         point.y=0.0;
1834         point.z=0.0;
1835         mutex->post();
1836         \textcolor{keywordflow}{return} point;
1837     \}
1838 
1839     CvScalar scal=cvGet2D(&disp16,v,u);
1840     \textcolor{keywordtype}{double} disparity=scal.val[0]/16.0;
1841     \textcolor{keywordtype}{float} w= (float) ((\textcolor{keywordtype}{float}) disparity*Q.at<\textcolor{keywordtype}{double}>(3,2)) + ((float)Q.at<\textcolor{keywordtype}{double}>(3,3));
1842     point.x= (float)((\textcolor{keywordtype}{float}) (usign+1)*Q.at<\textcolor{keywordtype}{double}>(0,0)) + ((\textcolor{keywordtype}{float}) Q.at<\textcolor{keywordtype}{double}>(0,3));
1843     point.y=(float)((\textcolor{keywordtype}{float}) (vsign+1)*Q.at<\textcolor{keywordtype}{double}>(1,1)) + ((\textcolor{keywordtype}{float}) Q.at<\textcolor{keywordtype}{double}>(1,3));
1844     point.z=(float) Q.at<\textcolor{keywordtype}{double}>(2,3);
1845 
1846     point.x=point.x/w;
1847     point.y=point.y/w;
1848     point.z=point.z/w;
1849 
1850     \textcolor{comment}{// discard points far more than thMeters meters or with not valid disparity (<0)}
1851     \textcolor{keywordflow}{if}(point.z>thMeters || point.z<0) \{
1852         point.x=0.0;
1853         point.y=0.0;
1854         point.z=0.0;
1855     \} 
1856     \textcolor{keywordflow}{else} \{
1857             Mat P(3,1,CV\_64FC1);
1858             P.at<\textcolor{keywordtype}{double}>(0,0)=point.x;
1859             P.at<\textcolor{keywordtype}{double}>(1,0)=point.y;
1860             P.at<\textcolor{keywordtype}{double}>(2,0)=point.z;
1861 
1862             \textcolor{comment}{// Rototranslation from rectified camera to original camera}
1863             P=this->getRLrect().t()*P;
1864 
1865             point.x=(float) P.at<\textcolor{keywordtype}{double}>(0,0);
1866             point.y=(float) P.at<\textcolor{keywordtype}{double}>(1,0);
1867             point.z=(float) P.at<\textcolor{keywordtype}{double}>(2,0);
1868     \}
1869  
1870     mutex->post();
1871     \textcolor{keywordflow}{return} point;
1872 
1873 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!metric\+Triangulation@{metric\+Triangulation}}
\index{metric\+Triangulation@{metric\+Triangulation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{metric\+Triangulation}]{\setlength{\rightskip}{0pt plus 5cm}Point3f Stereo\+Camera\+::metric\+Triangulation (
\begin{DoxyParamCaption}
\item[{Point2f \&}]{point1, }
\item[{Mat \&}]{H, }
\item[{double}]{th\+Meters = {\ttfamily 10}}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a3cf53fac6336eea107a26bd5cdbbdd03}


It performs the metric triangulation given the pixel coordinates on the first image. 

The 3\+D Point is w.\+r.\+t the system defined by the parameter H. Run compute disparity before using this method. 
\begin{DoxyParams}{Parameters}
{\em point1} & the pixel coordinates in the first image. \\
\hline
{\em H} & the 4x4 rototranslation matrix of the system. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a metric 3\+D point w.\+r.\+t. the reference system defined by H. 
\end{DoxyReturn}


Definition at line 1877 of file stereo\+Camera.\+cpp.



References get\+Disparity16(), get\+Mapper\+L(), and get\+R\+Lrect().


\begin{DoxyCode}
1877                                                                                   \{
1878     mutex->wait();
1879 
1880     \textcolor{keywordflow}{if}(H.empty())
1881         H=H.eye(4,4,CV\_64FC1);
1882 
1883     \textcolor{keywordflow}{if}(Q.empty() || Disparity16.empty()) \{
1884         cout << \textcolor{stringliteral}{"Run computeDisparity() method first!"} << endl;
1885         Point3f point;
1886         point.x=0.0;
1887         point.y=0.0;
1888         point.z=0.0;
1889         mutex->post();
1890         \textcolor{keywordflow}{return} point;
1891     \}
1892 
1893     \textcolor{keywordtype}{int} u=(int) point1.x; \textcolor{comment}{// matrix starts from (0,0), pixels from (1,1)}
1894     \textcolor{keywordtype}{int} v=(\textcolor{keywordtype}{int}) point1.y;
1895     Point3f point;
1896 
1897 
1898     \textcolor{comment}{// Mapping from Rectified Cameras to Original Cameras}
1899     Mat Mapper=this->getMapperL();
1900 
1901     \textcolor{keywordflow}{if}(Mapper.empty()) \{
1902         point.x=0.0;
1903         point.y=0.0;
1904         point.z=0.0;
1905         
1906         mutex->post();
1907         \textcolor{keywordflow}{return} point;
1908     \}
1909 
1910 
1911     \textcolor{keywordtype}{float} usign=Mapper.ptr<\textcolor{keywordtype}{float}>(v)[2*u];
1912     \textcolor{keywordtype}{float} vsign=Mapper.ptr<\textcolor{keywordtype}{float}>(v)[2*u+1]; 
1913 
1914     u=cvRound(usign);
1915     v=cvRound(vsign);
1916 
1917     IplImage disp16=this->getDisparity16();
1918     
1919 
1920     \textcolor{keywordflow}{if}(u<0 || u>=disp16.width || v<0 || v>=disp16.height) \{
1921         point.x=0.0;
1922         point.y=0.0;
1923         point.z=0.0;
1924         mutex->post();
1925         \textcolor{keywordflow}{return} point;
1926     \}
1927 
1928     CvScalar scal=cvGet2D(&disp16,v,u);
1929     \textcolor{keywordtype}{double} disparity=scal.val[0]/16.0;
1930     \textcolor{keywordtype}{float} w= (float) ((\textcolor{keywordtype}{float}) disparity*Q.at<\textcolor{keywordtype}{double}>(3,2)) + ((float)Q.at<\textcolor{keywordtype}{double}>(3,3));
1931     point.x= (float)((\textcolor{keywordtype}{float}) (usign+1)*Q.at<\textcolor{keywordtype}{double}>(0,0)) + ((\textcolor{keywordtype}{float}) Q.at<\textcolor{keywordtype}{double}>(0,3));
1932     point.y=(float)((\textcolor{keywordtype}{float}) (vsign+1)*Q.at<\textcolor{keywordtype}{double}>(1,1)) + ((\textcolor{keywordtype}{float}) Q.at<\textcolor{keywordtype}{double}>(1,3));
1933     point.z=(float) Q.at<\textcolor{keywordtype}{double}>(2,3);
1934 
1935     point.x=point.x/w;
1936     point.y=point.y/w;
1937     point.z=point.z/w;
1938 
1939     \textcolor{comment}{// discard points far more than thMeters meters or with not valid disparity (<0)}
1940     \textcolor{keywordflow}{if}(point.z>thMeters || point.z<0) \{
1941         point.x=0.0;
1942         point.y=0.0;
1943         point.z=0.0;
1944         mutex->post();
1945         \textcolor{keywordflow}{return} point;
1946     \} 
1947 
1948     Mat RLrectTmp=this->getRLrect().t();
1949     Mat Tfake = Mat::zeros(0,3,CV\_64F);
1950     Mat P(4,1,CV\_64FC1);
1951     P.at<\textcolor{keywordtype}{double}>(0,0)=point.x;
1952     P.at<\textcolor{keywordtype}{double}>(1,0)=point.y;
1953     P.at<\textcolor{keywordtype}{double}>(2,0)=point.z;
1954     P.at<\textcolor{keywordtype}{double}>(3,0)=1;
1955 
1956     Mat Hrect=buildRotTras(RLrectTmp,Tfake);
1957     P=H*Hrect*P;
1958 
1959     point.x=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(0,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
1960     point.y=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(1,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
1961     point.z=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(2,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
1962 
1963     mutex->post();
1964     \textcolor{keywordflow}{return} point;
1965 
1966 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!project\+Points3\+D@{project\+Points3\+D}}
\index{project\+Points3\+D@{project\+Points3\+D}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{project\+Points3\+D}]{\setlength{\rightskip}{0pt plus 5cm}vector$<$ Point2f $>$ Stereo\+Camera\+::project\+Points3\+D (
\begin{DoxyParamCaption}
\item[{string}]{camera, }
\item[{vector$<$ Point3f $>$ \&}]{points3\+D, }
\item[{Mat \&}]{H}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a03406c9d31c1b765a8d6ef9641222309}


The method returns the 2\+D projection of a set of 3\+D points in the cartesian space to the specified camera. 


\begin{DoxyParams}{Parameters}
{\em camera} & \char`\"{}left\char`\"{} or \char`\"{}right\char`\"{} camera \\
\hline
{\em point3\+D} & the list of the 3\+D position in the reference frame H \\
\hline
{\em H} & the transformation from the camera reference system to the H reference system \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The 2\+D positions. 
\end{DoxyReturn}


Definition at line 2028 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2029 \{
2030     vector<Point2f> points2D;
2031 
2032     \textcolor{keywordflow}{if}(this->Kleft.empty() || this->DistL.empty() || this->Kright.empty() || this->DistR.empty()) \{
2033         cout <<\textcolor{stringliteral}{" Cameras are not calibrated! Run the Calibration first!"} << endl;
2034         \textcolor{keywordflow}{return} points2D;
2035     \}
2036 
2037     \textcolor{keywordflow}{if}(H.empty())
2038         H=H.eye(4,4,CV\_64FC1);
2039 
2040     mutex->wait();
2041 
2042     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<points3D.size(); i++)
2043     \{   
2044         \textcolor{comment}{// Apply inverse Trasformation for each point}
2045         Point3f point=points3D[i];
2046         Mat P(4,1,CV\_64FC1);
2047         P.at<\textcolor{keywordtype}{double}>(0,0)=point.x;
2048         P.at<\textcolor{keywordtype}{double}>(1,0)=point.y;
2049         P.at<\textcolor{keywordtype}{double}>(2,0)=point.z;
2050         P.at<\textcolor{keywordtype}{double}>(3,0)=1;
2051 
2052         P=H.inv()*P;
2053 
2054         point.x=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(0,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2055         point.y=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(1,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2056         point.z=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(2,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2057 
2058         points3D[i]=point;
2059     \}
2060 
2061     Mat cameraMatrix, distCoeff, rvec, tvec;
2062     rvec=Mat::zeros(3,1,CV\_64FC1);
2063 
2064     \textcolor{keywordflow}{if}(camera==\textcolor{stringliteral}{"left"})
2065     \{
2066         cameraMatrix=this->Kleft;
2067         distCoeff=this->DistL;
2068         Mat R2= Mat::eye(3,3,CV\_64FC1);
2069         Rodrigues(R2,rvec);
2070         tvec=Mat::zeros(3,1,CV\_64FC1);
2071     \}
2072     \textcolor{keywordflow}{else}
2073     \{
2074         cameraMatrix=this->Kright;
2075         distCoeff=this->DistR;
2076         Mat R2= this->R;
2077         Rodrigues(R2,rvec);
2078         tvec=this->T;
2079     \}
2080 
2081     Mat points3Mat(points3D);
2082     projectPoints(points3Mat,rvec,tvec,cameraMatrix,distCoeff,points2D);
2083     mutex->post();
2084 
2085     \textcolor{keywordflow}{return} points2D;
2086 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!rectify\+Images@{rectify\+Images}}
\index{rectify\+Images@{rectify\+Images}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{rectify\+Images}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::rectify\+Images (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_ae5ac866c6d4b6c4819b01a918e7b61e0}


The method rectifies the two images\+: it transform each image plane such that pairs conjugate epipolar lines become collinear and parallel to one of the image axes (i.\+e. 

there is 0 disparity on the Y axis). 

Definition at line 407 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
408 \{
409     \textcolor{keywordflow}{if}(this->Kleft.empty() || this->DistL.empty() || this->Kright.empty() || this->DistR.empty()) \{
410         cout <<\textcolor{stringliteral}{" Cameras are not calibrated! Run the Calibration first!"} << endl;
411         \textcolor{keywordflow}{return};
412     \}
413     \textcolor{keywordflow}{if}(this->imleft.empty() || this->imright.empty()) \{
414           cout << \textcolor{stringliteral}{"Images are not set! set the images first!"} << endl;
415           \textcolor{keywordflow}{return};
416     \}
417     Size img\_size = this->imleft.size();
418 
419     \textcolor{keywordflow}{if}(cameraChanged)
420     \{
421         mutex->wait();
422         stereoRectify(this->Kleft, this->DistL, this->Kright, this->DistR, img\_size, this->R, this->T, 
      this->RLrect, this->RRrect, this->PLrect, this->PRrect, this->Q, -1);
423 
424         mutex->post();
425     \}
426 
427     \textcolor{keywordflow}{if}(cameraChanged)
428     \{
429         initUndistortRectifyMap(this->Kleft, this->DistL, this->RLrect, this->PLrect, img\_size, CV\_32FC1, 
      this->map11, this->map12);
430         initUndistortRectifyMap(this->Kright,  this->DistR, this->RRrect, this->PRrect, img\_size, CV\_32FC1,
       this->map21, this->map22);
431     \}
432     
433     Mat img1r, img2r;
434     remap(this->imleft, img1r, this->map11, this->map12, cv::INTER\_LINEAR);
435     remap(this->imright, img2r, this->map21,this->map22, cv::INTER\_LINEAR);
436     imgLeftRect=img1r;
437     imgRightRect=img2r;
438 
439 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!save\+Calibration@{save\+Calibration}}
\index{save\+Calibration@{save\+Calibration}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{save\+Calibration}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::save\+Calibration (
\begin{DoxyParamCaption}
\item[{string}]{extrinsic\+File\+Path, }
\item[{string}]{intrinsic\+File\+Path}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a9f06cd4b170ad0ba45b681ee93d64851}


It saves the calibration. 


\begin{DoxyParams}{Parameters}
{\em extrinsic\+File\+Path} & the path of the extrinsic parameters file \\
\hline
{\em intrinsic\+File\+Path} & the path of the intrinsic parameters file \\
\hline
\end{DoxyParams}


Definition at line 327 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
327                                                                                      \{
328 
329     \textcolor{keywordflow}{if}( Kleft.empty() || Kright.empty() || DistL.empty() || DistR.empty() || R.empty() || T.empty()) \{
330             cout << \textcolor{stringliteral}{"Error: cameras are not calibrated! Run the calibration or set intrinsic and extrinsic
       parameters \(\backslash\)n"};
331             \textcolor{keywordflow}{return};
332     \}
333 
334     FileStorage fs(intrinsicFilePath+\textcolor{stringliteral}{".yml"}, CV\_STORAGE\_WRITE);
335     \textcolor{keywordflow}{if}( fs.isOpened() )
336     \{
337         fs << \textcolor{stringliteral}{"M1"} << Kleft << \textcolor{stringliteral}{"D1"} << DistL << \textcolor{stringliteral}{"M2"} << Kright << \textcolor{stringliteral}{"D2"} << DistR;
338         fs.release();
339     \}
340     \textcolor{keywordflow}{else}
341         cout << \textcolor{stringliteral}{"Error: can not save the intrinsic parameters\(\backslash\)n"};
342 
343     fs.open(extrinsicFilePath+\textcolor{stringliteral}{".yml"}, CV\_STORAGE\_WRITE);
344     \textcolor{keywordflow}{if}( fs.isOpened() )
345     \{
346         fs << \textcolor{stringliteral}{"R"} << R << \textcolor{stringliteral}{"T"} << T <<\textcolor{stringliteral}{"Q"} << Q;
347         fs.release();
348     \}
349     \textcolor{keywordflow}{else}
350         cout << \textcolor{stringliteral}{"Error: can not save the intrinsic parameters\(\backslash\)n"};
351 
352 
353 
354     ofstream fout((intrinsicFilePath+\textcolor{stringliteral}{".ini"}).c\_str());
355 
356     \textcolor{comment}{// Left Eye}
357     fout << \textcolor{stringliteral}{"[left]"} << endl;
358     fout << \textcolor{stringliteral}{"fx "} << Kleft.at<\textcolor{keywordtype}{double}>(0,0) << endl;
359     fout << \textcolor{stringliteral}{"fy "} << Kleft.at<\textcolor{keywordtype}{double}>(1,1) << endl;
360     fout << \textcolor{stringliteral}{"cx "} << Kleft.at<\textcolor{keywordtype}{double}>(0,2) << endl;
361     fout << \textcolor{stringliteral}{"cy "} << Kleft.at<\textcolor{keywordtype}{double}>(1,2) << endl;
362     fout << \textcolor{stringliteral}{"k1 "} << DistL.at<\textcolor{keywordtype}{double}>(0,0) << endl;
363     fout << \textcolor{stringliteral}{"k2 "} << DistL.at<\textcolor{keywordtype}{double}>(1,0) << endl;
364     fout << \textcolor{stringliteral}{"p1 "} << DistL.at<\textcolor{keywordtype}{double}>(2,0) << endl;
365     fout << \textcolor{stringliteral}{"p2 "} << DistL.at<\textcolor{keywordtype}{double}>(3,0) << endl;
366 
367     \textcolor{comment}{// Right Eye}
368     fout << \textcolor{stringliteral}{"[right]"} << endl;
369     fout << \textcolor{stringliteral}{"fx "} << Kright.at<\textcolor{keywordtype}{double}>(0,0) << endl;
370     fout << \textcolor{stringliteral}{"fy "} << Kright.at<\textcolor{keywordtype}{double}>(1,1) << endl;
371     fout << \textcolor{stringliteral}{"cx "} << Kright.at<\textcolor{keywordtype}{double}>(0,2) << endl;
372     fout << \textcolor{stringliteral}{"cy "} << Kright.at<\textcolor{keywordtype}{double}>(1,2) << endl;
373     fout << \textcolor{stringliteral}{"k1 "} << DistR.at<\textcolor{keywordtype}{double}>(0,0) << endl;
374     fout << \textcolor{stringliteral}{"k2 "} << DistR.at<\textcolor{keywordtype}{double}>(1,0) << endl;
375     fout << \textcolor{stringliteral}{"p1 "} << DistR.at<\textcolor{keywordtype}{double}>(2,0) << endl;
376     fout << \textcolor{stringliteral}{"p2 "} << DistR.at<\textcolor{keywordtype}{double}>(3,0) << endl;
377 
378     fout.close();
379 
380 
381 
382 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!set\+Expected\+Position@{set\+Expected\+Position}}
\index{set\+Expected\+Position@{set\+Expected\+Position}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{set\+Expected\+Position}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::set\+Expected\+Position (
\begin{DoxyParamCaption}
\item[{Mat \&}]{Rot, }
\item[{Mat \&}]{Tran}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a9ecb303d7b36eaf5f086d8ddebd29b95}


The function set the expected Rotation and Translation parameters for the current image pair. 

They can be computed using the Kinematics. 
\begin{DoxyParams}{Parameters}
{\em Rot} & 3x3 matrix representing the rotation between the left and the right camera. \\
\hline
{\em Tran} & 3x1 vector representing the translation between the left and the right camera. \\
\hline
\end{DoxyParams}


Definition at line 2266 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2267 \{
2268     R\_exp=Rot;
2269     T\_exp=Tran; 
2270 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!set\+Images@{set\+Images}}
\index{set\+Images@{set\+Images}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{set\+Images}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::set\+Images (
\begin{DoxyParamCaption}
\item[{Ipl\+Image $\ast$}]{first\+Img, }
\item[{Ipl\+Image $\ast$}]{second\+Img}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a5e24f7d17a11adb4a6310df7f7e2de5b}


It stores in memory a couple of images. 


\begin{DoxyParams}{Parameters}
{\em first\+Img} & the images acquired from the first (main) camera \\
\hline
{\em second\+Img} & the images acquired from the second (secondary) camera \\
\hline
\end{DoxyParams}


Definition at line 102 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
102                                                               \{
103        this->imleft=left;
104        this->imright=right;
105 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!set\+Intrinsics@{set\+Intrinsics}}
\index{set\+Intrinsics@{set\+Intrinsics}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{set\+Intrinsics}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::set\+Intrinsics (
\begin{DoxyParamCaption}
\item[{Mat \&}]{K1, }
\item[{Mat \&}]{K2, }
\item[{Mat \&}]{Dist1, }
\item[{Mat \&}]{Dist2}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a54754623497c8dddb61f520e17f465f8}


It sets the intrinsic parameters. 


\begin{DoxyParams}{Parameters}
{\em K1} & 3x3 camera matrix of the first camera. \\
\hline
{\em K2} & 3x3 camera matrix of the second camera. \\
\hline
{\em Dist1} & 4x1 distortion coefficients vector of the first camera. \\
\hline
{\em Dist2} & 4x1 distortion coefficients vector of the second camera. \\
\hline
\end{DoxyParams}


Definition at line 1776 of file stereo\+Camera.\+cpp.



Referenced by Stereo\+Camera().


\begin{DoxyCode}
1776                                                                          \{
1777     this->mutex->wait();
1778     this->Kleft=KL;
1779     this->Kright=KR;
1780     this->DistL=DistL;
1781     this->DistR=DistR;
1782 
1783     \textcolor{keywordflow}{if}(!this->R.empty() && !this->T.empty())
1784         updatePMatrix();
1785     this->cameraChanged=\textcolor{keyword}{true};
1786     buildUndistortRemap();
1787     this->mutex->post();
1788 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!set\+Matches@{set\+Matches}}
\index{set\+Matches@{set\+Matches}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{set\+Matches}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::set\+Matches (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ cv\+::\+Point2f $>$ \&}]{points\+L, }
\item[{std\+::vector$<$ cv\+::\+Point2f $>$ \&}]{points\+R}
\end{DoxyParamCaption}
)}\label{classStereoCamera_ae683fafa11ea73e4b4c278402be259b6}


The function initialize the matches of the current image pair. 

For example matches can be computed in G\+P\+U with higher framerate. 
\begin{DoxyParams}{Parameters}
{\em points\+L} & vector of Point2f representing the keypoints on the left image. \\
\hline
{\em points\+R} & vector of Point2f representing the keypoints on the right image. \\
\hline
\end{DoxyParams}


Definition at line 2258 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
2259 \{
2260     PointsL=pointsL;
2261     PointsR=pointsR;
2262 
2263 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!set\+Rotation@{set\+Rotation}}
\index{set\+Rotation@{set\+Rotation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{set\+Rotation}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::set\+Rotation (
\begin{DoxyParamCaption}
\item[{Mat \&}]{Rot, }
\item[{int}]{mode = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a1329b3894d527e1505618f57a1304624}


It sets the rotation matrix (if known) between the first and the second camera. 


\begin{DoxyParams}{Parameters}
{\em Rot} & the 3x3 rotation matrix. \\
\hline
{\em mode} & the following values are allowed\+: {\bfseries mode=0} the rotation matrix R is set equal to Rot. {\bfseries mode=1} the rotation matrix R is set equal to Rot$\ast$\+R. {\bfseries mode=2} the rotation matrix R is set equal to Rot$\ast$\+Rinit. \\
\hline
\end{DoxyParams}


Definition at line 1351 of file stereo\+Camera.\+cpp.



Referenced by Stereo\+Camera().


\begin{DoxyCode}
1351                                                 \{
1352     this->mutex->wait();
1353     \textcolor{keywordflow}{if}(mul==0)
1354         this->R=Rot;
1355     \textcolor{keywordflow}{if}(mul==1)
1356         this->R=Rot*R;
1357     \textcolor{keywordflow}{if}(mul==2)
1358         this->R=Rot*Rinit;
1359         
1360     \textcolor{keywordflow}{if}(R\_exp.empty())
1361        R\_exp=R;
1362     this->updatePMatrix();
1363     this->cameraChanged=\textcolor{keyword}{true};
1364     this->mutex->post();
1365 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!set\+Translation@{set\+Translation}}
\index{set\+Translation@{set\+Translation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{set\+Translation}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::set\+Translation (
\begin{DoxyParamCaption}
\item[{Mat \&}]{Tras, }
\item[{int}]{mul = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a7b10f1218e8e70f47b22080ba1820d39}


It sets the translation vector (if known) between the first and the second camera. 


\begin{DoxyParams}{Parameters}
{\em Tras} & the 3x1 translation matrix. \\
\hline
{\em mode} & the following values are allowed\+: {\bfseries mode=0} the translation vector T is set equal to Tras. {\bfseries mode=1} the translation vector T is set equal to Tras+\+T. {\bfseries mode=2} the translation vector T is set equal to Tras+\+Tinit. \\
\hline
\end{DoxyParams}


Definition at line 1367 of file stereo\+Camera.\+cpp.



Referenced by Stereo\+Camera().


\begin{DoxyCode}
1367                                                     \{
1368     this->mutex->wait();
1369     \textcolor{keywordflow}{if}(mul==0)
1370         this->T=Tras;
1371     \textcolor{keywordflow}{if}(mul==1)
1372         this->T=Tras+T;
1373     \textcolor{keywordflow}{if}(mul==2)
1374         this->T=Tras+Tinit;
1375 
1376     \textcolor{keywordflow}{if}(T\_exp.empty())
1377         T\_exp=T;
1378         
1379     \textcolor{keywordflow}{if}(!this->Kleft.empty() && !this->Kright.empty())
1380         this->updatePMatrix();
1381     this->cameraChanged=\textcolor{keyword}{true};
1382     this->mutex->post();
1383 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!stereo\+Calibration@{stereo\+Calibration}}
\index{stereo\+Calibration@{stereo\+Calibration}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{stereo\+Calibration}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::stereo\+Calibration (
\begin{DoxyParamCaption}
\item[{vector$<$ string $>$}]{image\+List, }
\item[{int}]{board\+Width, }
\item[{int}]{board\+Height, }
\item[{float}]{sqsize = {\ttfamily 1.0}}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a398f45eeefe7979a834659cfbb7a6961}


It performs the stereo camera calibration. 

(see stereo\+Calibration module) 
\begin{DoxyParams}{Parameters}
{\em image\+List} & is the list containing the paths of the images with the chessboard patterns. even indices refer to Left camera images (i.\+e. main camera images), while odd indices refer to Right camera images. \\
\hline
{\em board\+Width} & the number of inner corners in the width direction of the chess board pattern (see stereo\+Calibration module) \\
\hline
{\em board\+Height} & the number of inner corners in the height direction of the chess board pattern (see stereo\+Calibration module) \\
\hline
{\em sqsize} & the size of the square of the chess board pattern. It is needed for a metric reconstruction. \\
\hline
\end{DoxyParams}


Definition at line 120 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
120                                                                                                            
      \{
121     Size boardSize;
122     boardSize.width=boardWidth;
123     boardSize.height=boardHeight;
124     runStereoCalib(imagelist, boardSize,sqsize);
125 
126 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!triangulate\+Known\+Disparity@{triangulate\+Known\+Disparity}}
\index{triangulate\+Known\+Disparity@{triangulate\+Known\+Disparity}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{triangulate\+Known\+Disparity}]{\setlength{\rightskip}{0pt plus 5cm}Point3f Stereo\+Camera\+::triangulate\+Known\+Disparity (
\begin{DoxyParamCaption}
\item[{float}]{u, }
\item[{float}]{v, }
\item[{float}]{d, }
\item[{Mat \&}]{H}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a761ea623c4cde38b4fa1d798ef09b7ae}


It performs the metric triangulation given the pixel coordinates on the first image and the disparity between the two R\+E\+C\+T\+I\+F\+I\+E\+D images. 

The 3\+D Point is w.\+r.\+t the system defined by the parameter H. 
\begin{DoxyParams}{Parameters}
{\em u} & the pixel x coordinate in the first image. \\
\hline
{\em v} & the pixel y coordinate in the first image. \\
\hline
{\em d} & the disparity on the x coordinate between the two rectified images. \\
\hline
{\em H} & the 4x4 rototranslation matrix of the system can be an empty matrix. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a metric 3\+D point w.\+r.\+t. the reference system defined by H. 
\end{DoxyReturn}


Definition at line 1969 of file stereo\+Camera.\+cpp.



References get\+R\+Lrect().


\begin{DoxyCode}
1970 \{
1971     mutex->wait();
1972     \textcolor{keywordflow}{if}(Q.empty())
1973     \{
1974         cout << \textcolor{stringliteral}{"Run rectifyImages() method first!"} << endl;
1975         Point3f point;
1976         point.x=0.0;
1977         point.y=0.0;
1978         point.z=0.0;
1979         mutex->post();
1980         \textcolor{keywordflow}{return} point;
1981     \}
1982 
1983     \textcolor{keywordflow}{if}(H.empty())
1984         H=H.eye(4,4,CV\_64FC1);
1985 
1986     Point3f point;
1987 
1988     \textcolor{keywordtype}{float} w= (float) ((\textcolor{keywordtype}{float}) d*Q.at<\textcolor{keywordtype}{double}>(3,2)) + ((float)Q.at<\textcolor{keywordtype}{double}>(3,3));
1989     point.x= (float)((\textcolor{keywordtype}{float}) (u)*Q.at<\textcolor{keywordtype}{double}>(0,0)) + ((\textcolor{keywordtype}{float}) Q.at<\textcolor{keywordtype}{double}>(0,3));
1990     point.y=(float)((\textcolor{keywordtype}{float}) (v)*Q.at<\textcolor{keywordtype}{double}>(1,1)) + ((\textcolor{keywordtype}{float}) Q.at<\textcolor{keywordtype}{double}>(1,3));
1991     point.z=(float) Q.at<\textcolor{keywordtype}{double}>(2,3);
1992 
1993     \textcolor{comment}{// Rectified Camera System}
1994     point.x=point.x/w;
1995     point.y=point.y/w;
1996     point.z=point.z/w;
1997 
1998     \textcolor{comment}{// We transform to H Coordinate System}
1999     Mat RLrectTmp=this->getRLrect().t(); \textcolor{comment}{// First it transform the point to the unrectified camera
       reference system}
2000     Mat Tfake = Mat::zeros(0,3,CV\_64F);
2001     Mat P(4,1,CV\_64FC1);
2002     P.at<\textcolor{keywordtype}{double}>(0,0)=point.x;
2003     P.at<\textcolor{keywordtype}{double}>(1,0)=point.y;
2004     P.at<\textcolor{keywordtype}{double}>(2,0)=point.z;
2005     P.at<\textcolor{keywordtype}{double}>(3,0)=1;
2006 
2007     Mat Hrect=buildRotTras(RLrectTmp,Tfake);
2008     P=H*Hrect*P;
2009 
2010     point.x=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(0,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2011     point.y=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(1,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2012     point.z=(float) ((\textcolor{keywordtype}{float}) P.at<\textcolor{keywordtype}{double}>(2,0)/P.at<\textcolor{keywordtype}{double}>(3,0));
2013 
2014     mutex->post();
2015     \textcolor{keywordflow}{return} point;
2016 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!triangulation@{triangulation}}
\index{triangulation@{triangulation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{triangulation}]{\setlength{\rightskip}{0pt plus 5cm}Point3f Stereo\+Camera\+::triangulation (
\begin{DoxyParamCaption}
\item[{Point2f \&}]{point1, }
\item[{Point2f \&}]{point2}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a3c8ef84424fa111c63437a3db8f04333}


It performs the triangulation using the stored in the internal P1 and P2 3x4 \hyperlink{classCamera}{Camera} Matrices. 

The triangulation obtained is not metric! Use the method metric\+Triangulation if you want a metric triangulation. 
\begin{DoxyParams}{Parameters}
{\em point1} & the 2\+D point coordinates in the first image. \\
\hline
{\em point2} & the 2\+D point coordinates in the second image. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a 3\+D point wrt the first camera reference system. 
\end{DoxyReturn}


Definition at line 678 of file stereo\+Camera.\+cpp.



Referenced by chierality().


\begin{DoxyCode}
678                                                                            \{
679       
680       Point3f point3D;
681       Mat J=Mat(4,4,CV\_64FC1);
682       J.setTo(0);
683       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<4; j++) \{
684 
685             \textcolor{keywordtype}{int} rowA=0;
686             \textcolor{keywordtype}{int} rowB=2;
687 
688             J.at<\textcolor{keywordtype}{double}>(0,j)=(pointleft.x*this->Pleft.at<\textcolor{keywordtype}{double}>(rowB,j))- (this->Pleft.at<\textcolor{keywordtype}{double}>(rowA,j)
      );
689             J.at<\textcolor{keywordtype}{double}>(2,j)=(pointRight.x*this->Pright.at<\textcolor{keywordtype}{double}>(rowB,j))- (this->Pright.at<\textcolor{keywordtype}{double}>(rowA
      ,j));
690 
691             rowA=1;
692             
693             J.at<\textcolor{keywordtype}{double}>(1,j)=(pointleft.y*this->Pleft.at<\textcolor{keywordtype}{double}>(rowB,j))- (this->Pleft.at<\textcolor{keywordtype}{double}>(rowA,j)
      );
694             J.at<\textcolor{keywordtype}{double}>(3,j)=(pointRight.y*this->Pright.at<\textcolor{keywordtype}{double}>(rowB,j))- (this->Pright.at<\textcolor{keywordtype}{double}>(rowA
      ,j));
695         \}
696         SVD decom(J);
697         Mat V= decom.vt;
698 
699         point3D.x=(float) ((\textcolor{keywordtype}{float}) V.at<\textcolor{keywordtype}{double}>(3,0))/((float) V.at<\textcolor{keywordtype}{double}>(3,3));
700         point3D.y=(float) ((\textcolor{keywordtype}{float}) V.at<\textcolor{keywordtype}{double}>(3,1))/((float) V.at<\textcolor{keywordtype}{double}>(3,3));     
701         point3D.z=(float) ((\textcolor{keywordtype}{float}) V.at<\textcolor{keywordtype}{double}>(3,2))/((float) V.at<\textcolor{keywordtype}{double}>(3,3));
702         \textcolor{keywordflow}{return} point3D;
703 
704 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!triangulation@{triangulation}}
\index{triangulation@{triangulation}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{triangulation}]{\setlength{\rightskip}{0pt plus 5cm}Point3f Stereo\+Camera\+::triangulation (
\begin{DoxyParamCaption}
\item[{Point2f \&}]{point1, }
\item[{Point2f \&}]{point2, }
\item[{Mat}]{Camera1, }
\item[{Mat}]{Camera2}
\end{DoxyParamCaption}
)}\label{classStereoCamera_ab68c8d3bd07f542243d681fbe8c8c6b7}


It performs the triangulation (H\+Z Chap 12.\+2 homogenous solution). 

The triangulation obtained is not metric! Use the method metric\+Triangulation if you want a metric triangulation. 
\begin{DoxyParams}{Parameters}
{\em point1} & the 2\+D point coordinates in the first image. \\
\hline
{\em point2} & the 2\+D point coordinates in the second image. \\
\hline
{\em Camera1} & the 3x4 camera matrix of the first image. \\
\hline
{\em Camera2} & the 3x4 camera matrix of the second image. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a 3\+D point wrt the first camera reference system. 
\end{DoxyReturn}


Definition at line 1191 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1191                                                                                                      \{
1192 
1193       Point3f point3D;
1194       Mat J=Mat(4,4,CV\_64FC1);
1195       J.setTo(0);
1196                 
1197       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} j=0; j<4; j++) \{
1198 
1199             \textcolor{keywordtype}{int} rowA=0;
1200             \textcolor{keywordtype}{int} rowB=2;
1201 
1202             J.at<\textcolor{keywordtype}{double}>(0,j)=(pointleft.x*Camera1.at<\textcolor{keywordtype}{double}>(rowB,j))- (Camera1.at<\textcolor{keywordtype}{double}>(rowA,j));
1203             J.at<\textcolor{keywordtype}{double}>(2,j)=(pointRight.x*Camera2.at<\textcolor{keywordtype}{double}>(rowB,j))- (Camera2.at<\textcolor{keywordtype}{double}>(rowA,j));
1204 
1205             rowA=1;
1206             
1207             J.at<\textcolor{keywordtype}{double}>(1,j)=(pointleft.y*Camera1.at<\textcolor{keywordtype}{double}>(rowB,j))- (Camera1.at<\textcolor{keywordtype}{double}>(rowA,j));
1208             J.at<\textcolor{keywordtype}{double}>(3,j)=(pointRight.y*Camera2.at<\textcolor{keywordtype}{double}>(rowB,j))- (Camera2.at<\textcolor{keywordtype}{double}>(rowA,j));
1209         \}
1210         SVD decom(J);
1211         Mat V= decom.vt;
1212 
1213        \textcolor{comment}{// printMatrix(V);}
1214         
1215         \textcolor{comment}{/*Mat sol=Mat(4,1,CV\_64FC1);}
1216 \textcolor{comment}{        sol.at<double>(0,0)=V.at<double>(0,0);}
1217 \textcolor{comment}{        sol.at<double>(1,0)=V.at<double>(1,1);}
1218 \textcolor{comment}{        sol.at<double>(2,0)=V.at<double>(2,2);}
1219 \textcolor{comment}{        sol.at<double>(3,0)=V.at<double>(3,3);}
1220 \textcolor{comment}{        }
1221 \textcolor{comment}{        Mat test=J*sol;}
1222 \textcolor{comment}{        }
1223 \textcolor{comment}{        printMatrix(test);*/}
1224         point3D.x=(float) ((\textcolor{keywordtype}{float}) V.at<\textcolor{keywordtype}{double}>(3,0))/((float) V.at<\textcolor{keywordtype}{double}>(3,3));
1225         point3D.y=(float) ((\textcolor{keywordtype}{float}) V.at<\textcolor{keywordtype}{double}>(3,1))/((float) V.at<\textcolor{keywordtype}{double}>(3,3));     
1226         point3D.z=(float) ((\textcolor{keywordtype}{float}) V.at<\textcolor{keywordtype}{double}>(3,2))/((float) V.at<\textcolor{keywordtype}{double}>(3,3));
1227         \textcolor{keywordflow}{return} point3D;
1228 
1229 \}
\end{DoxyCode}
\index{Stereo\+Camera@{Stereo\+Camera}!triangulation\+L\+S@{triangulation\+L\+S}}
\index{triangulation\+L\+S@{triangulation\+L\+S}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{triangulation\+L\+S}]{\setlength{\rightskip}{0pt plus 5cm}Point3f Stereo\+Camera\+::triangulation\+L\+S (
\begin{DoxyParamCaption}
\item[{Point2f \&}]{point1, }
\item[{Point2f \&}]{point2, }
\item[{Mat}]{Camera1, }
\item[{Mat}]{Camera2}
\end{DoxyParamCaption}
)}\label{classStereoCamera_aaef25d8723eefdbab6e27c348492126b}


It performs the least square triangulation (H\+Z Chap 12.\+2 Inhomogenous solution). 

The triangulation obtained is not metric! Use the method metric\+Triangulation if you want a metric triangulation. 
\begin{DoxyParams}{Parameters}
{\em point1} & the 2\+D point coordinates in the first image. \\
\hline
{\em point2} & the 2\+D point coordinates in the second image. \\
\hline
{\em Camera1} & the 3x4 camera matrix of the first image. \\
\hline
{\em Camera2} & the 3x4 camera matrix of the second image. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a 3\+D point wrt the first camera reference system. 
\end{DoxyReturn}
\index{Stereo\+Camera@{Stereo\+Camera}!undistort\+Images@{undistort\+Images}}
\index{undistort\+Images@{undistort\+Images}!Stereo\+Camera@{Stereo\+Camera}}
\subsubsection[{undistort\+Images}]{\setlength{\rightskip}{0pt plus 5cm}void Stereo\+Camera\+::undistort\+Images (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classStereoCamera_a2751f357e5fabc7099303d45425208d7}


It undistorts the images. 

\begin{DoxyNote}{Note}
Set undistortion coefficients before using this method. 
\end{DoxyNote}


Definition at line 1324 of file stereo\+Camera.\+cpp.


\begin{DoxyCode}
1324                                    \{
1325     \textcolor{keywordflow}{if}(this->Kleft.empty() || this->DistL.empty() || this->Kright.empty() || this->DistR.empty()) \{
1326         cout <<\textcolor{stringliteral}{" Cameras are not calibrated! Run the Calibration first!"} << endl;
1327         \textcolor{keywordflow}{return};
1328     \}
1329     \textcolor{keywordflow}{if}(this->imleft.empty() || this->imright.empty()) \{
1330           cout << \textcolor{stringliteral}{"Images are not set! set the images first!"} << endl;
1331           \textcolor{keywordflow}{return};
1332     \}
1333         
1334     undistort(this->imleft,this->imleftund,this->Kleft,this->DistL);
1335     undistort(this->imright,this->imrightund,this->Kright,this->DistR);
1336 \}
\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/dev/icub-\/contrib-\/iit/stereo-\/vision/lib/include/i\+Cub/stereo\+Vision/stereo\+Camera.\+h\item 
C\+:/dev/icub-\/contrib-\/iit/stereo-\/vision/lib/src/stereo\+Camera.\+cpp\end{DoxyCompactItemize}
